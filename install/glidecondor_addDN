#!/usr/bin/env python

#
# Project:
#   glideinWMS
#
# File Version: 
#
# Description:
#   This tool adds a DN to the Condor security configuration
#
# Author:
#   Igor Sfiligoi @UCSD (Apr 2010)
#
# Part of the glideinWMS package
#

import sys
import os
import os.path
import subprocess
import stat
import time
import re
import M2Crypto

STARTUP_DIR=sys.path[0]
sys.path.append(os.path.join(STARTUP_DIR,"../.."))

from glideinwms.lib.x509Support import extract_DN
from glideinwms.lib import condorExe

def usage():
    print "Usage:"
    print " glidecondor_addDN [-q] [-daemon comment] DN|certfile user"
    return

def parse_args(args):
    QUIET_OPS=False
    
    daemon_comment=None
    if len(args)<2:
        usage()
        sys.exit(1)

    if (args[0]=='-help') or (args[0]=='-h') or (args[0]=='--help'):
        usage()
        sys.exit(1)

    if args[0]=='-q':
        QUIET_OPS=True
        args=args[1:]
        
    if args[0]=='-daemon':
        daemon_comment=args[1]
        if len(daemon_comment)<10:
            print "Daemon comment must be at least 10 characters long"
            sys.exit(1)
        args=args[2:]

    if len(args)!=2:
        usage()
        sys.exit(1)
    dn=args[0]
    user=args[1]

    if dn.startswith("file:") or os.path.isfile(dn):
        # not a DN... it is really a file
        # extract the DN
        if dn.startswith("file:"):
            fname=dn.split(':',1)[1]
        else:
            fname=dn
        if not QUIET_OPS:
            print "Reading certificate file '%s'"%fname
        dn=extract_DN(fname)
        if not QUIET_OPS:
            print "Using DN '%s'"%dn
    
    return QUIET_OPS,{'is_daemon_dn':(daemon_comment!=None),'daemon_comment':daemon_comment,'dn':dn,'user':user}

def check_config(fname):
    if not os.path.isfile(fname):
        raise IOError,"Config file '%s' not found!"%fname

    if not os.access(fname,os.R_OK|os.W_OK):
        raise IOError, "Config file '%s' not writable!"%fname

    return # file seems OK

def update_mapfile(mapfile,dnlist):
    mapmode=os.stat(mapfile)[stat.ST_MODE]
    fd=open(mapfile,'r')
    lines=fd.readlines()
    fd.close()

    if len(lines)<2:
        # must have at least the GSI anon and FS anon
        print "File '%s' is not a condor mapfile; too short!"%mapfile
        sys.exit(3)

    if lines[0][:4]!='GSI ':
        print "File '%s' is not a condor mapfile; first line is not a valid GSI mapping!"%mapfile
        sys.exit(3)
        
    # append GSI DN user
    # after the last line of that kind
    found=False
    for i in range(0,len(lines)):
        line=lines[i]
        if line[:5]!='GSI "':
            for dnel in dnlist:
                dn=dnel['dn']
                user=dnel['user']
                lines.insert(i,'GSI "^%s$" %s\n'%(re.escape(dn),user))
            found=True
            break
    if not found:
        print "File '%s' is not valid a condor mapfile; only plain GSI mappings found!"%mapfile
        sys.exit(3)

    # will overwrite the mapfile
    # but create a tmpfile first, so it is semi-atomic
    tmpfile="%s.new"%mapfile
    if os.path.isfile(tmpfile):
        os.unlink(tmpfile)
    
    fd=open(tmpfile,'w')
    fd.writelines(lines)
    fd.close()
    os.chmod(tmpfile,mapmode)

    bakfile="%s~"%mapfile
    if os.path.isfile(bakfile):
        os.unlink(bakfile)
    os.rename(mapfile,bakfile)
    os.rename(tmpfile,mapfile)

    return

def update_config(config_file,dnlist):
    # just append at the end of the file
    fd=open(config_file,'a')
    for dnel in dnlist:
        dn=dnel['dn']
        user=dnel['user']
        comment=dnel['daemon_comment']
        fd.write("\n# New daemon DN added on %s\n"%time.ctime())
        fd.write("# Comment: %s\n"%comment)
        fd.write("# The following DN will map to %s\n"%user)
        fd.write("GSI_DAEMON_NAME=$(GSI_DAEMON_NAME),%s\n"%dn)
    fd.close()

    return

def main(args):
    # parse the arguments, so we know what the user want
    QUIET_OPS,params=parse_args(args)

    # make sure we can access the files to be changed
    try:
        try:
             condor_mapfile=condorExe.iexe_cmd("condor_config_val CERTIFICATE_MAPFILE")[0].rstrip('\n')
        except condorExe.ExeError,e:
             raise IOError, "Path to CERTIFICATE_MAPFILE not found"

        check_config(condor_mapfile)
        if params['is_daemon_dn']:
            has_dir=False
            try:
                 condor_config_dir=condorExe.iexe_cmd("condor_config_val LOCAL_CONFIG_DIR")[0].rstrip('\n')
                 has_dir=os.path.exists(condor_config_dir)
                 condor_config=os.path.join(condor_config_dir,"90_gwms_dns.config")
                 if not os.path.isfile(condor_config):
                     print "Please create %s"%condor_config
            except condorExe.ExeError,e:
                has_dir=False

            if has_dir:
                 condor_config=os.path.join(condor_config_dir,"90_gwms_dns.config")
                 if not os.path.isfile(condor_config):
                     raise IOError, "Please create %s"%condor_config
            else:
                 # not found, see if it uses a config dir
                 try:
                    condor_config=condorExe.iexe_cmd("condor_config_val LOCAL_CONFIG_FILE")[0].rstrip('\n')
                 except condorExe.ExeError,e:
                     # nope, go with the main config file
                     try:
                         condor_config=condorExe.iexe_cmd("condor_config_val -config")[1].strip() # it is in the second line, and it is indented
                     except condorExe.ExeError,e:
                         raise IOError, "No CONFIG_FILE found"
            try:
                check_config(condor_config)
            except IOError, e:
                raise IOError, e
    except IOError, e:
        print e
        sys.exit(2)

    #now do the changes
    update_mapfile(condor_mapfile,[params])
    if params['is_daemon_dn']:
        update_config(condor_config,[params])

    if not QUIET_OPS:
        print "Configuration files changed."
        print "Remember to reconfig the affected Condor daemons."
        print

    return 0

if __name__ == '__main__':
    main(sys.argv[1:])
