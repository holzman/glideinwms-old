#!/bin/env python

import sys,os,os.path,string,time
import pwd,grp
import shutil
import tarfile,readline,pwd
import md5
import getpass
import re
import xml.sax.saxutils
import socket
import stat
import httplib
import ftplib
STARTUP_DIR=sys.path[0]
sys.path.append(os.path.join(STARTUP_DIR,"../lib"))
import xmlFormat

#############################
#
# Global variables
#
#############################

# What port does the HTTPd listening on
HTTPD_PORT=None
# Where is RRD installed
RRD_BIN_PATH=None
# Where is javascriptRRD installed
JAVASCRIPTRRD_PATH=None
# Where is Flot installed
FLOT_PATH=None
# CONDOR_BASE_PATH will point to the base condor directory when condor is installed
CONDOR_BASE_PATH=None
# Where should the changes to Condor go
CONDOR_UPD_CONFIG_FILE=None
# Where is the OSG VDT client installed (if any)
VDT_BASE_PATH=None
# voms_proxy_info location (if false, the user already said it does not have one installed)
VOMS_PROXY_INFO_BIN=None
# where are the certificates
GSI_TRUSTED_CA_DIR=None
# Has the GSI securtiy been configured
GSI_SECURITY_CONFIGURED=0
# Which port the PostgreSQL is running, if installed 
POSTGRESQL_PORT=None
# What are the passwords used for quill? (None means not configured yet)
# Will be a disctionary of reader and writer
QUILL_DB_PASSWDS=None
# Were Condor config parameters set?
QUILL_CONFIG_DONE=0
# Has the secondary support files been installed yet?
SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED=0

# Was a condor collector installed on this machine?
PRIVSEP_INSTALLED=0
# Was a condor collector installed on this machine?
COLLECTOR_INSTALLED=0
# Was a main schedd configured on this machine?
MAIN_SCHEDD_INSTALLED=0
# Condor user
CONDOR_IDS = ""


##########################################
#
# Main of the intallation procedure
#
##########################################

#-------------------------------------------------------------------------------
def installer(install_options):
    print "What do you want to install?"
    print "(May select several options at one, using a , separated list)"
    opt_keys=install_options.keys()
    opt_keys.sort()
    for k in opt_keys:
        print "[%s] %s"%(k,install_options[k]["title"])

    have_valid_select=0
    while not have_valid_select:
        selected_options_str=raw_input("Please select: ")
        selected_options=selected_options_str.split(",")
        have_valid_select=1 # assume valid unless disprooved
        for s in selected_options:
            if not install_options.has_key(s):
                print "Invalid option [%s]!"%s
                have_valid_select=0 # re-ask
                break

    selected_options.sort(lambda x,y:cmp(install_options[x]["order"],(install_options[y]["order"])))

    print
    print "The following profiles will be installed:"
    for k in selected_options:
        print "[%s] %s"%(k,install_options[k]["title"])
    print
    
    for k in selected_options:
        install_options[k]["proc"]()
    return

#-------------------------------------------------------------------------------
def main():
    install_options={"1":{"title":"glideinWMS Schedds and Collector",
                          "proc":wms_install,"order":13},
                     "2":{"title":"Glidein Factory",
                          "proc":gfactory_install,"order":16},
                     "3":{"title":"GCB","proc":gcb_install,"order":15}, #must be after any other condor
                     "4":{"title":"User Pool Collector",
                          "proc":collector_install,"order":11}, # must be before any schedd
                     "5":{"title":"User Schedd",
                          "proc":schedd_node_install,"order":12},
                     "6":{"title":"Condor for VO Frontend",
                          "proc":condor_frontend_install,"order":14},
                     "7":{"title":"VO Frontend",
                          "proc":vofrontend_install,"order":17},
                     '8':{"title":"Components",
                          "proc":main_install_components,"order":1}}
                     
    print "Welcome to the glideinWMS Installation Helper"
    print ""
    return installer(install_options)

#-------------------------------------------------------------------------------
def main_install_components():
    install_options={'a':{"title":"OSG VDT client",
                          "proc":query_vdt,"order":1},
                     'b':{"title":"Base Condor installation",
                          "proc":install_condor,"order":2}}

    if os.getuid()==0:
        install_options['c']={"title":"Web server",
                              "proc":install_httpd,"order":3}
        install_options['d']={"title":"rrdtool graphics package",
                              "proc":install_rrd,"order":4}
        install_options['e']={"title":"PostgreSQL database",
                              "proc":install_postgresql,"order":5}
        install_options['f']={"title":"Quill-specific PostgreSQL database",
                              "proc":query_quill_db,"order":6}

                     
    return installer(install_options)

##########################################
#
# Subset specific procedures
#
##########################################

#-------------------------------------------------------------------------------
def collector_install():
    global CONDOR_BASE_PATH
    global GSI_SECURITY_CONFIGURED
    global COLLECTOR_INSTALLED

    print "Installing pool collector"
    print

    condor_was_installed=(CONDOR_BASE_PATH!=None)
    if CONDOR_BASE_PATH==None:
        install_condor()

    if not GSI_SECURITY_CONFIGURED:
        gsi_setup = { 'server': 'Pool Collector',
                      'client': 'User Schedd, Glidein Startd',
                      'server_comment': 'Its subject (i.e. DN) will be added as the trusted daemon \nin the condor configuration.',
                      'client_comment': 'The User Schedd(s) and Glidein startds will connect to \nand act as daemons to the Pool Collector. Any other node or process \nthat needs to talk securely with the Collector (like the \nVO Frontend) also needs to be authenticated, but not as \na daemon. Finally, if you expect any processes on this node \nto use condor security toward other nodes (e.g. the VO Frontend \ntalking to the WMS Collector), the remote services will also \nneed to be authenticated. The subjects (i.e. DNs) \nfor these services will thus most likely be needed.'
                    }
        configure_gsi_security(gsi_setup)

    if not COLLECTOR_INSTALLED:
        while 1:
            nr_collectors_default=5
            nr_collectors_str=raw_input("How many slave collectors do you want?: [5] ")
            if nr_collectors_str=="":
                nr_collectors_str="%s"%nr_collectors_default
            try:
                nr_collectors=int(nr_collectors_str)
            except:
                print "'%s' is not a number!"%nr_collectors_str
                continue
            if nr_collectors<0:
                print "You entered a negative number! (%i)"%nr_collectors
                continue
            if nr_collectors>399: # security check
                print "You entered too big of a number! (%i)"%nr_collectors
                continue

            break # have the number of collectors

        setup_collector('My pool',nr_collectors)

    restart_condor()

    print "**************************************************"
    print "Pool collector installation succeeded"
    print "**************************************************"
    print
    
    return

#-------------------------------------------------------------------------------
def schedd_node_install():
    global CONDOR_BASE_PATH
    global GSI_SECURITY_CONFIGURED
    global QUILL_CONFIG_DONE
    global SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED
    global COLLECTOR_INSTALLED
    global MAIN_SCHEDD_INSTALLED
    global CONDOR_UPD_CONFIG_FILE

    print "Installing user submit schedds"
    print

    condor_was_installed=(CONDOR_BASE_PATH!=None)
    if CONDOR_BASE_PATH==None:
        install_condor()

    if not GSI_SECURITY_CONFIGURED:
        gsi_setup = { 'server': 'User Schedd',
                      'client': 'User Pool Collector, Glidein Startd, VO Frontend',
                      'server_comment': 'Its subject (i.e. DN) will be added as the trusted daemon \nin the condor configuration.',
                      'client_comment': 'The schedd will need to talk to the Pool Collector on a \ndaemon to daemon level. The Glidein startds will also need \nto be authenticated as daemons. Any other node or process \nthat needs to talk securely with the schedd (like the \nVO Frontend) also needs to be authenticated, but not as \na daemon. Finally, if you expect any processes on this node \nto use condor security toward other nodes (e.g. the VO Frontend \ntalking to the WMS Collector), the remote services will also \nneed to be authenticated. The subjects (i.e. DNs) \nfor these services will thus most likely be needed.',
                    }
        configure_gsi_security(gsi_setup)

    # USE_MATCH_AUTH
    print
    print "Condor supports a more efficient Match authentication that is also more secure."
    print "Newer versions of the VO Frontend will not work if you don't enable it,"
    print "but you may still be able to use this schedd for other purposes."
    while 1:
        match_yn=raw_input("Do you want to enable Match authentication?: (y/n) ")
        if match_yn=="":
            match_yn="y"
        if (match_yn!="y") and (match_yn!="n"):
            print "Please answer y or n"
            continue 
        break
    if match_yn=='y':
        print
        print "Make sure you use Match authentication in the glideins, too"
        print
        
        config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
        try:
            config_fd.write("\n#####################################\n")
            config_fd.write("# Enable match authentication\n")
            config_fd.write("#####################################\n")
            config_fd.write("SEC_ENABLE_MATCH_PASSWORD_AUTHENTICATION=TRUE\n")
        finally:
            config_fd.close()

    # Don't even ask... nobody uses 6.8.X anymore
    #if not QUILL_CONFIG_DONE:
    #    yn=raw_input("Do you want to Use Quill (works for 6.8.X only)?: (y/n) [n]")
    #    if yn=='y':
    #        setup_quill()

    if not MAIN_SCHEDD_INSTALLED:
        setup_main_schedd()

    ###################################
    # configure the GCB routing tables
    gcb_list=get_gcb_list()

    if len(gcb_list)>0: # do not need to configure if not using GCBs at all
        config_fd=open("%s/etc/gcb-routing-table"%CONDOR_BASE_PATH,"w")
        try:
            for gcb_entry in gcb_list:
                config_fd.write("%s/32 GCB\n"%gcb_entry)
        finally:
            config_fd.close()

        config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
        try:
            config_fd.write("#####################################\n")
            config_fd.write("# Tell schedd daemons where is GCB\n")
            config_fd.write("#####################################\n")
            config_fd.write("SCHEDD.NET_REMAP_ENABLE=TRUE\n")
            config_fd.write("SCHEDD.NET_REMAP_SERVICE=GCB\n")
            config_fd.write("SCHEDD.NET_REMAP_ROUTE=%s/etc/gcb-routing-table\n\n"%CONDOR_BASE_PATH)
        finally:
            config_fd.close()

    ##################################
    # configure secondary schedds
    if not SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED:
        create_secondary_schedd_support_files()
    
    while 1:
        nr_schedds_default=9
        nr_schedds_str=raw_input("How many secondary schedds do you want?: [9] ")
        if nr_schedds_str=="":
            nr_schedds_str="%s"%nr_schedds_default
        try:
            nr_schedds=int(nr_schedds_str)
        except:
            print "'%s' is not a number!"%nr_schedds_str
            continue
        if nr_schedds<0:
            print "You entered a negative number! (%i)"%nr_schedds
            continue
        if nr_schedds>99: # security check
            print "You entered too big of a number! (%i)"%nr_schedds
            continue

        break # have the number of schedds

    for i in range(nr_schedds):
        schedd_name="jobs%i"%(i+1)
        configure_secondary_schedd(schedd_name)

    restart_condor()

    print "**************************************************"
    print "User submit schedd installation succeeded"
    print "**************************************************"
    print
        
    return

#-------------------------------------------------------------------------------
def wms_install():
    global CONDOR_BASE_PATH
    global GSI_SECURITY_CONFIGURED
    global QUILL_CONFIG_DONE
    global SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED
    global COLLECTOR_INSTALLED
    global CONDOR_UPD_CONFIG_FILE

    print "Installing WMS Schedds and Collector"
    print

    if os.getuid()!=0:
        print
        print "The WMS schedds and collector should be installed as root to get"
        print "the privilege separation need to securely support multiple frontends."
        print "By installing as a non-privileged user, you loose this feature."
        yn=raw_input("Do you want to continue?: (y/n) ")
        if yn!='y':
            print
            print "Not installing  WMS Schedds and Collector."
            print "Remember to install it as a root."
            print
            return


    condor_was_installed=(CONDOR_BASE_PATH!=None)
    if CONDOR_BASE_PATH==None:
        install_condor()

    if os.getuid()==0:
        if not PRIVSEP_INSTALLED:
            setup_privsep()

    needed_gsi_security_config=False
    if not GSI_SECURITY_CONFIGURED:
        needed_gsi_security_config=True
        gsi_setup = { 'server': 'WMS Collector',
                      'client': 'VO Frontend',
                      'server_comment': 'Its subject (i.e. DN) will be added as the trusted daemon \nin the condor configuration.',
                      'client_comment': 'The VO Frontend(s) will be contacting the WMS Collector \nand will interact as daemons. Their subjects (i.e. DNs) \nwill most likely be needed.'
                    }
        configure_gsi_security(gsi_setup)

    # Don't even ask... nobody uses 6.8.X anymore
    #if not QUILL_CONFIG_DONE:
    #    yn=raw_input("Do you want to Use Quill (works for 6.8.X only)?: (y/n) [n]")
    #    if yn=='y':
    #        setup_quill()

    if not COLLECTOR_INSTALLED:
        setup_collector('My glideinWMS pool',0) # no secondary collectors
    
    if not MAIN_SCHEDD_INSTALLED:
        setup_main_schedd()

    if needed_gsi_security_config:
        ###########################
        # Limit master and schedd
        # to only local access
         
        # DISABLE: Igor
        # Does not seem to work in v7.4.1
        # Collector will pick up the MASTER variables!
        pass 
        #config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
        #try:
        #    config_fd.write("\n######################################################\n")
        #    config_fd.write("## Limit master and schedd to only local access\n")
        #    config_fd.write("######################################################\n\n")
        #    for dm in ('MASTER','SCHEDD'):
        #        config_fd.write("%s.network_interface=127.0.0.1\n"%dm)
        #        config_fd.write("%s.bind_all_interfaces=False\n"%dm)
        #        config_fd.write("%s.SEC_DEFAULT_AUTHENTICATION_METHODS=FS\n"%dm)
        #finally:
        #    config_fd.close()

        

    ################################
    # Set optimized Condor-G values
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## Condor-G tuning\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("GRIDMANAGER_LOG = /tmp/GridmanagerLog.$(SCHEDD_NAME).$(USERNAME)\n")
        config_fd.write("GRIDMANAGER_MAX_SUBMITTED_JOBS_PER_RESOURCE=5000\n")
        config_fd.write("GRIDMANAGER_MAX_PENDING_SUBMITS_PER_RESOURCE=5000\n")
        config_fd.write("GRIDMANAGER_MAX_PENDING_REQUESTS=500\n")
    finally:
        config_fd.close()

    ##################################
    # configure secondary schedds
    if not SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED:
        create_secondary_schedd_support_files()
    
    while 1:
        nr_schedds_default=9
        nr_schedds_str=raw_input("How many secondary schedds do you want?: [9] ")
        if nr_schedds_str=="":
            nr_schedds_str="%s"%nr_schedds_default
        try:
            nr_schedds=int(nr_schedds_str)
        except:
            print "'%s' is not a number!"%nr_schedds_str
            continue
        if nr_schedds<0:
            print "You entered a negative number! (%i)"%nr_schedds
            continue
        if nr_schedds>99: # security check
            print "You entered too big of a number! (%i)"%nr_schedds
            continue

        break # have the number of schedds

    for i in range(nr_schedds):
        schedd_name="glideins%i"%(i+1)
        configure_secondary_schedd(schedd_name)

    restart_condor()

    print "******************************************"
    print "WMS collector successfully installed"
    print "******************************************"
    print

    return

#-------------------------------------------------------------------------------
def condor_frontend_install():
    global CONDOR_BASE_PATH
    global GSI_TRUSTED_CA_DIR
    global CONDOR_UPD_CONFIG_FILE

    if (CONDOR_BASE_PATH==None):
        if os.getuid()==0:
            print
            print "You are trying to install Condor for the VO Frontend as root"
            print "While this is possible, it is not recommended."
            print "For security reasons, it is better to install it as a non-priviledged user"
            yn=raw_input("Do you want to continue?: (y/n) ")
            if yn!='y':
                print
                print "Not installing Condor for VO Frontend as root."
                print "Remember to install it as a regular user"
                print
                return

    print
    print "Installing Condor for VO Frontend"
    print

    if CONDOR_BASE_PATH==None:
        install_condor()

        if not GSI_SECURITY_CONFIGURED:
            gsi_setup = { 'server': 'Condor',
                          'client': 'VO Frontend',
                          'server_comment': 'Its subject (i.e. DN) will be added in the condor configuration.',
                          'client_comment': 'The VO Frontend will need to securely talk to \nthe WMS Collector, the Pool Collector and the user schedd(s).\nThe subjects (i.e. DNs) for these services will most likely be needed.',
                          }
            configure_gsi_security(gsi_setup)

        if not MAIN_SCHEDD_INSTALLED:
            setup_main_schedd()

        ####################################################
        # If used only for the VO frontend, disable daemons
        config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
        try:
            config_fd.write("\n######################################################\n")
            config_fd.write("## This machine should run no daemons\n")
            config_fd.write("######################################################\n")
            config_fd.write("DAEMON_LIST=MASTER\n")
            config_fd.write("DAEMON_SHUTDOWN=True\n\n")
        finally:
            config_fd.close()
    # else nothing to be done

    #
    # No need to start condor, client only
    #

    print
    print "Condor for VO Frontend installed"
    print
    return

#-------------------------------------------------------------------------------
def gcb_install():
    global CONDOR_BASE_PATH
    global COLLECTOR_INSTALLED
    global MAIN_SCHEDD_INSTALLED
    global QUILL_CONFIG_DONE
    global CONDOR_UPD_CONFIG_FILE
    
    if os.getuid()==0:
        print
        print "You are trying to install GCB as root"
        print "While this is possible, it is not recommended."
        print "For security reasons, it is better to install it as a non-priviledged user"
        yn=raw_input("Do you want to continue?: (y/n) ")
        if yn!='y':
            print
            print "Not installing GCB as root."
            print "Remember to install it as a regular user"
            print
            return
    print
    print "Installing GCB"
    print
    if CONDOR_BASE_PATH==None:
        install_condor()

    ################################
    # Configure GCB
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## GCB configuration\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("# Define the path to the broker binary for the master to spawn\n")
        config_fd.write("GCB_BROKER = $(RELEASE_DIR)/libexec/gcb_broker\n\n")

        config_fd.write("# Define the path to the release_server binary for the broker to use\n")
        config_fd.write("GCB_RELAY = $(RELEASE_DIR)/libexec/gcb_relay_server\n\n")

        config_fd.write("# Setup the gcb_broker's environment.  We use a macro to build up the\n")
        config_fd.write("# environment we want in pieces, and then finally define\n")
        config_fd.write("# GCB_BROKER_ENVIRONMENT, the setting that condor_master uses.\n\n")

        config_fd.write("# Initialize an empty macro\n")
        config_fd.write("GCB_BROKER_ENV =\n\n")

        config_fd.write("# (recommended) Provide the full path to the gcb_relay_server\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_RELAY_SERVER=$(GCB_RELAY)\n\n")

        config_fd.write("# (recommended) Tell GCB to write all log files into the Condor log\n")
        config_fd.write("# directory (the directory used by the condor_master itself)\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_LOG_DIR=$(LOG)\n")
        config_fd.write("# Or, you can specify a log file seperately for each GCB daemon:\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_BROKER_LOG=$(LOG)/GCB_Broker_Log;GCB_RELAY_SERVER_LOG=$(LOG)/GCB_RS_Log\n\n")

        config_fd.write("# (optional -- only set if true) Tell the GCB broker that it can\n")
        config_fd.write("# directly connect to machines in the private network which it is\n")
        config_fd.write("# handling communication for.  This should only be enabled if the GCB\n")
        config_fd.write("# broker is running directly on a network boundry and can open direct\n")
        config_fd.write("# connections to the private nodes.\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);ACTIVE_TO_CLIENT=yes\n\n")

        config_fd.write("# (optional) turn on verbose logging for all of GCB\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_DEBUG_LEVEL=fulldebug\n")
        config_fd.write("# Or, you can turn this on seperately for each GCB daemon:\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_BROKER_DEBUG=fulldebug\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_RELAY_SERVER_DEBUG=fulldebug\n\n")

        config_fd.write("# (optional) specify the maximum log file size (in bytes)\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_MAX_LOG=6400000\n")
        config_fd.write("# Or, you can define this seperately for each GCB daemon:\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_BROKER_MAX_LOG=64000000\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_RELAY_SERVER_MAX_LOG=640000\n\n")

        config_fd.write("# How many connections should it serve\n")
        config_fd.write("# By multiplying the two you get the number of used ports\n")
        config_fd.write("# If you increase it, make sure your machine supports enough port\n")
        config_fd.write("#   see /proc/sys/net/ipv4/ip_local_port_range\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_MAX_RELAY_SERVERS=200\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_MAX_CLIENTS_PER_RELAY_SERVER=100\n\n")

        config_fd.write("# How tolerant should it be to blocked connections\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_COMMAND_TIMEOUT=1.5\n\n")

        config_fd.write("# Finally, set the value the condor_master really uses\n")
        config_fd.write("GCB_BROKER_ENVIRONMENT = $(GCB_BROKER_ENV)\n\n")

        config_fd.write("# If your Condor installation on this host already has a public\n")
        config_fd.write("# interface as the default (either because it is the first interface\n")
        config_fd.write("# listed in this machine's host entry, or because you've already\n")
        config_fd.write("# defined NETWORK_INTERFACE), you can just use Condor's special macro\n")
        config_fd.write("# that holds the IP address for this.\n")
        config_fd.write("GCB_BROKER_IP = $(ip_address)\n")
        config_fd.write("# Otherwise, you could define it yourself with your real public IP:\n")
        config_fd.write("#GCB_BROKER_IP = 131.225.70.222\n\n")

        config_fd.write("# (required) define the command-line arguments for the broker\n")
        config_fd.write("GCB_BROKER_ARGS = -i $(GCB_BROKER_IP)\n")
    finally:
        config_fd.close()

    
    ################################
    # Enable the GCB daemon
    daemon_list="MASTER"

    if COLLECTOR_INSTALLED:
        daemon_list=daemon_list+", COLLECTOR, NEGOTIATOR" 
    if MAIN_SCHEDD_INSTALLED:
        daemon_list=daemon_list+", SCHEDD" 
        if QUILL_CONFIG_DONE:
            daemon_list=daemon_list+", QUILL" 

    if (not COLLECTOR_INSTALLED) and (not MAIN_SCHEDD_INSTALLED):
        # this is a fresh install, I need a private collector
        daemon_list=daemon_list+", COLLECTOR"

    ################################
    # Configure GCB
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## Add GCB to the list of daemons\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("DAEMON_LIST = %s, GCB_BROKER\n\n"%daemon_list)
    finally:
        config_fd.close()

    restart_condor()

    print
    print "GCB installed"
    print
    return

#-------------------------------------------------------------------------------
# find out where the stage and monitor subdirs will be created
# create, the dirs, too
def query_WebLocation(web_subdir):
    while 1:
        default_web_base_dir='/var/www/html/'+web_subdir
        web_base_dir=create_empty_dir("Where will the web data be hosted?: ",default_web_base_dir,empty_required=False)

        # create stage and monitor subdirs, if needed
        for sdir_name in ("stage","monitor"):
            sdir_fullpath=os.path.join(web_base_dir,sdir_name)
            if not os.path.exists(sdir_fullpath):
                try:
                    os.mkdir(sdir_fullpath)
                except:
                    print "Cannot create dir '%s'"%sdir_fullpath
                    continue

                test_fname=os.path.join(sdir_fullpath,"test.txt")
                try:
                    fd=open(test_fname,"w")
                    fd.close()
                    os.unlink(test_fname)
                except:
                    print "Dir '%s' not writable."%sdir_fullpath
                    continue
        break # everything worked, go on 
        

    # Web URL
    full_host_name=socket.getfqdn()
    if HTTPD_PORT==None:
        default_web_base_url="http://%s/%s/"%(full_host_name,web_subdir)
    else:
        default_web_base_url="http://%s:%s/%s/"%(full_host_name,HTTPD_PORT,web_subdir)

    while 1:
        web_base_url=raw_input("What Web URL will you use?: [%s] "%default_web_base_url)
        if web_base_url=="":
            web_base_url=default_web_base_url

        if web_base_url[-1]!='/':
            web_base_url+='/'

        if web_base_url[:7]=="http://":
            web_url_type="http"
            web_base_url_noproto=web_base_url[7:]
        elif web_base_url[:8]=="https://":
            yn=raw_input("HTTPS is quite expensive and cannot be cached?\nAre you sure you want to use it? : (y/n) ")
            if yn!="y":
                continue
            web_url_type="https"
            web_base_url_noproto=web_base_url[8:]
        elif web_base_url[:6]=="ftp://":
            yn=raw_input("FTP will usually not be cached?\nAre you sure you want to use it? : (y/n) ")
            if yn!="y":
                continue
            web_url_type="ftp"
            web_base_url_noproto=web_base_url[6:]
        else:
            tmp=web_base_url.split(':',1)
            print "Unknown protocol %s (http, https and ftp supported)!"%tmp
            continue

        web_base_url_noproto_arr=web_base_url_noproto.split('/',1)
        if len(web_base_url_noproto_arr)!=2:
            print "Invalid URL: %s"%web_base_url
            continue

        web_base_url_host=web_base_url_noproto_arr[0]
        web_base_url_path=web_base_url_noproto_arr[1]

        if web_url_type=="ftp":
            try:
                fc=ftplib.FTP(web_base_url_host)
                rc=fc.login()
                rc=fc.cwd(web_base_url_path+"stage/")
                fc.close()
            except:
                print "Failed connecting to: %s"%web_base_url
                continue
        else:
            web_base_url_host_arr=web_base_url_host.split(':',1)
            web_base_url_host_name=web_base_url_host_arr[0]
            if len(web_base_url_host_arr)>1:
                try:
                    web_base_url_host_port=int(web_base_url_host_arr[1])
                except:
                    print "Invalid port number in URL: %s"%web_base_url
                    continue
            else:
                web_base_url_host_port=None

            try:
                if web_url_type=='http':
                    hc=httplib.HTTPConnection(web_base_url_host_name,web_base_url_host_port)
                else:
                    hc=httplib.HTTPSConnection(web_base_url_host_name,web_base_url_host_port)
                hc.connect()
                hc.request("GET", "/%sstage/"%web_base_url_path)
                rc = hc.getresponse()
                hc.close()
                if rc.status!=200:
                    raise RuntimeError,"http failed %i"%rc.status
            except:
                print "Failed connecting to: %s"%web_base_url
                continue

        # found and verified the installation
        break

    return (web_base_dir,web_base_url)

#-------------------------------------------------------------------------------
def gfactory_install():
    global HTTPD_PORT
    global JAVASCRIPTRRD_PATH,FLOT_PATH
    
    if os.getuid()==0:
        print
        print "You are trying to install the Glidein Factory as root"
        print "While this is possible, it is not recommended."
        print "For security reasons, it is better to install it as a non-priviledged user"
        yn=raw_input("Do you want to continue?: (y/n) [n] ")
        if yn!='y':
            print
            print "Not installing the Glidein Factory as root."
            print "Remember to install it as a regular user"
            print
            return

    print
    print "Installing Glidein Factory"
    print


    glideinWMS_base_dir=os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))
    if not os.path.isdir("%s/creation"%glideinWMS_base_dir):
        raise RuntimeError,"Cannot find %s/creation"%glideinWMS_base_dir

    check_import('rrdtool')
    check_import('M2Crypto')
    
    if JAVASCRIPTRRD_PATH==None:
        query_javascriptRRD()

    if FLOT_PATH==None:
        query_flot()

    ###################################
    # Ask about the proxy
    proxy_fname=None
    print "The Glidein Factory can be configured to use a default GSI proxy for submission.\n"
    print "However, this operation mode is not recommended.\n"
    while 1:
        match_yn=raw_input("Do you want to use such a proxy?: (y/n) [n] ")
        if match_yn=="":
            match_yn="n"
        if (match_yn!="y") and (match_yn!="n"):
            print "Please answer y or n"
            continue 
        break
    if match_yn=='y':
        print
        print "Subject of the Glidein Factory cert/proxy should be authenticated"
        print "and authorized at the compute elements (CE) you will be submitting"
        print "glidein jobs to."
        while 1:
            if os.environ.has_key('X509_USER_PROXY'):
                proxy_fname=raw_input("Where is your proxy located?: [%s] "%os.environ['X509_USER_PROXY'])
                if proxy_fname=="":
                    proxy_fname=os.environ['X509_USER_PROXY']
            else:
                proxy_fname=raw_input("Where is your proxy located?: ")
            proxy_fname=os.path.abspath(proxy_fname)

            if not os.path.isfile(proxy_fname):
                print "File not found: '%s'"%proxy_fname
                continue

            try:
                my_dn=get_proxy_dn(proxy_fname)
            except RuntimeError,e:
                print e
                continue

            break # proxy found

        print
        print "Using DN '%s'"%my_dn
        print "Make sure this DN is in the condor gridmap files of the User Pool collector and all the User schedds."
        print

    #################################
    # get config vals
    full_host_name=socket.getfqdn()
    fhn_arr=full_host_name.split(".")

    print
    print "As you probably know, privilege separation "
    print "is needed to securely support multiple frontends."
    print "If you are using privilege separation, the factory directories"
    print "must be world readable (except for the proxies dirs)"
    print
    print "Hosting the config and log files in the factory home directory"
    print "is thus not recommended anymore."
    print

    # Submit base directory
    def_submit_base_dir="/var/gfactory/glideinsubmit"

    submit_base_dir=create_empty_dir("Where will you host your config files?: ",def_submit_base_dir,empty_required=False)

    def_log_base_dir="/var/gfactory/glideinlogs"
    log_base_dir=create_empty_dir("Where will you host your log files?: ",def_log_base_dir,empty_required=False)

    def_clientlog_base_dir="/var/gfactory/clientlogs"
    while 1:
        clientlog_base_dir=raw_input("Where will you host the client log files?: [%s] "%def_clientlog_base_dir)
        if clientlog_base_dir=="":
            clientlog_base_dir=def_clientlog_base_dir
        if not os.path.isdir(clientlog_base_dir):
            print "%s does not exist, please create it if needed"%clientlog_base_dir
            continue
        break

    def_clientproxies_base_dir="/var/gfactory/clientproxies"
    while 1:
        clientproxies_base_dir=raw_input("Where will you host the client proxies files?: [%s]"%def_clientproxies_base_dir)
        if clientproxies_base_dir=="":
            clientproxies_base_dir=def_clientproxies_base_dir
        if not os.path.isdir(clientproxies_base_dir):
            print "%s does not exist, please create it if needed"%clientproxies_base_dir
            continue
        break

    (web_base_dir,web_base_url)=query_WebLocation('glidefactory');
    

    #if RRD_BIN_PATH==None:
    #    query_rrd()

    # Factory name
    def_factory_name="mySites-%s"%fhn_arr[0]
    factory_name=raw_input("Give a name to this Glidein Factory?: [%s] "%def_factory_name)
    if factory_name=="":
        factory_name=def_factory_name

    # Glidein name
    def_glidein_name="v1_0"
    while 1:
        glidein_name=raw_input("Give a name to this Glidein instance?: [%s] "%def_glidein_name)
        if glidein_name=="":
            glidein_name=def_glidein_name
        # check if dir already exists
        if os.path.exists('%s/glidein_%s'%(submit_base_dir,glidein_name)):
            print "Glidein '%s' already exists!"%glidein_name
            continue
        if os.path.exists('%s/glidein_%s.cfg'%(submit_base_dir,glidein_name)):
            print "Glidein config area for '%s' already exists!"%glidein_name
            continue

        #have it
        break

    # Condor base dir
    fd=os.popen("which condor_status")
    lines=fd.readlines()
    err=fd.close()
    if err!=None: # found
        raise RuntimeError, "Failed to detect condor installation!"
    def_condor_base_dir=os.path.dirname(os.path.dirname(lines[0][:-1])) 
    while 1:
        condor_base_dir=raw_input("What is the Condor base directory?: [%s] "%def_condor_base_dir)
        if condor_base_dir=="":
            condor_base_dir=def_condor_base_dir
        condor_startd_bin=os.path.join(condor_base_dir,'sbin/condor_startd')
        if not os.path.exists(condor_startd_bin):
            print "%s does not exist!"%condor_startd_bin
            continue
        # found and verified
        break

    # schedds
    fd=os.popen("condor_status -schedd -format '%s\n' Name")
    lines=fd.readlines()
    err=fd.close()
    if err!=None: # found
        raise RuntimeError, "Failed to fetch list of schedds!"

    default_schedds=[]
    for line in lines:
        line=line[:-1] #remove newline
        if line[:14]=="schedd_glidein":
            default_schedds.append(line)

    if len(default_schedds)==0:
        while 1:
            yn=raw_input("No glidein schedds in this pool.\nDo you want to use the other schedds? (y/n) ")
            if (yn!="y") and (yn!="n"):
                print "Please answer y or n"
                continue 
            break
        if yn=='y':
            default_schedds=[]
            for line in lines:
                line=line[:-1] #remove newline
                if len(line)>0:
                    default_schedds.append(line)
        else:
            raise RuntimeError, "No glidein schedds in this pool!"


    print "The following glidein schedds have been found:"
    for i in range(len(default_schedds)):
        print " [%i] %s"%(i+1,default_schedds[i])
    
    while 1:
        yn=raw_input("Do you want to use all of them?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 
        break

    if yn=="y":
        schedds=default_schedds
    else:
        print "Select the schedd indexes you want to use"
        print "Use a , separated list to use more than one"
        while 1:
            idxes=raw_input("Please select: ")
            idx_arr=idxes.split(',')
            problems=0
            for i in range(len(idx_arr)):
                try:
                    nr=int(idx_arr[i])
                    if (nr<1) or (nr>len(default_schedds)):
                        print "Index %i out of range"%nr
                        problems=1
                        break
                    idx_arr[i]=nr
                except:
                    print "'%s' is not an index!"%idx_arr[i]
            if problems:
                continue

            schedds=[]
            for idx in idx_arr:
                schedds.append(default_schedds[idx-1])
            
            # got them
            break
    print "Using %s"%schedds
    print

    # Use CCB
    while 1:
        ccb_yn=raw_input("Do you want to use CCB (requires Condor 7.3.0 or better)?: (y/n) ")
        if (ccb_yn!="y") and (ccb_yn!="n"):
            print "Please answer y or n"
            continue 
        break
    if ccb_yn!="y": # no GCB if CCB used
        # GCBs
        gcb_list=get_gcb_list()

    # Use gLExec
    while 1:
        glexec_yn=raw_input("Do you want to use gLExec?: (y/n) ")
        if (glexec_yn!="y") and (glexec_yn!="n"):
            print "Please answer y or n"
            continue 
        break
    
    # Security setup
    if proxy_fname!=None:
        while 1:
            voproxy_yn=raw_input("Force VO frontend to provide its own proxy?: (y/n) [y] ")
            if voproxy_yn=="":
                voproxy_yn="y"
                break
            if (voproxy_yn!="y") and (voproxy_yn!="n"):
                print "Please answer y or n"
                continue 
            break
    else:
        # no factory proxy, so I must use the VO proxy; no choice
        voproxy_yn="y"

    # entries
    entries_list={}

    vo=None # VOMS extensions are not required
    yn=raw_input("Do you want to fetch entries from RESS?: (y/n) [n] ")
    if yn=='y':
        if proxy_fname!=None:
            vo=None # VOMS extensions are not required
            try:
                vo=get_proxy_vo(proxy_fname)
            except RuntimeError:
                pass # VOMS extensions are not required
            
        get_ress_glidein_entries(vo,entries_list,glexec_yn=="y")

    yn=raw_input("Do you want to fetch entries from BDII?: (y/n) [n] ")
    if yn=='y':
        vo=None # VOMS extensions are not required
        if proxy_fname!=None:
            try:
                vo=get_proxy_vo(proxy_fname)
            except RuntimeError:
                pass # VOMS extensions are not required
            
        get_bdii_glidein_entries(vo,entries_list,glexec_yn=="y")

    print "Please list all additional glidein entry points,"
    while 1:
        print
        entry_name=raw_input("Entry name (leave empty when finished): ")
        if entry_name=="":
            if len(entries_list.keys())<1:
                print "You must instert at least one entry point"
                continue
            break

        if entry_name in entries_list.keys():
            print "You already insterted '%s'!"%entry_name
            continue
        gatekeeper_name=raw_input("Gatekeeper for '%s': "%entry_name)
        if gatekeeper_name=="":
            print "Gatekkeper cannot be empty!"
            continue
        rsl_name=raw_input("RSL for '%s': "%entry_name)
        work_dir=raw_input("Work dir for '%s': [.] "%entry_name)
        if work_dir=="":
            work_dir="."
        site_name=raw_input("Site name for '%s': [%s] "%(entry_name,entry_name))
        if site_name=="":
            site_name=entry_name
        glexec_path=""
        if glexec_yn=="y":
            glexec_path=raw_input("gLExec path for '%s': [OSG] "%entry_name)
            if glexec_path=="":
                glexec_path='OSG'
        else:
            glexec_path="NONE"
            
            
        entries_list[entry_name]={'gatekeeper':gatekeeper_name,'rsl':rsl_name,'gridtype':'gt2',
                                  'work_dir':work_dir,'site_name':site_name,'glexec_path':glexec_path,'is_ids':[]}
        

    # USE_MATCH_AUTH
    while 1:
        match_yn=raw_input("Should glideins use the more efficient Match authentication (works for Condor v7.1.3 and later)?: (y/n) [y] ")
        if match_yn=="":
            match_yn="y"
        if (match_yn!="y") and (match_yn!="n"):
            print "Please answer y or n"
            continue 
        break

    print
    print "For security reasons, we want to whitelist all the frontends that we will be serving."
    print "Each frontend should be segregated to its own (set of) username(s)."
    print "If you do not want privilege separation, you can still just use the factory user."
    print
    print "Please list the frontends you will be serving:"
    full_host_name=socket.getfqdn()
    frontends={}
    while 1:
        print
        frontend_name=raw_input("Frontend security name (leave empty when finished): ")
        if frontend_name=="":
            if len(frontends.keys())<1:
                print "You must list at least one frontend"
                continue
            break

        if frontend_name in frontends.keys():
            print "You already insterted '%s'!"%frontend_name
            continue

        frontend_identity=raw_input("Frontend identity (like vo1@%s): "%full_host_name)
        if frontend_identity=="":
            print "Frontend identity cannot be empty!"
            continue

        # each frontend could have multiple proxy security classes
        # ask for just one for simplicity
        
        frontend_secclass=raw_input("Frontend proxy security class: [frontend] ")
        if frontend_secclass=="":
            frontend_secclass="frontend"

        frontend_uid=raw_input("Username: ")
        try:
            pwd.getpwnam(frontend_uid)
        except:
            print "User '%s' does not exist!"%frontend_uid
            continue
        
        frontends[frontend_name]={'id':frontend_identity,'security_class':frontend_secclass,'user':frontend_uid}


    os.mkdir('%s/glidein_%s.cfg'%(submit_base_dir,glidein_name))
    
    #####################################
    # create config files
    cfg_name='%s/glidein_%s.cfg/glideinWMS.xml'%(submit_base_dir,glidein_name)
    fd=open(cfg_name,"w")
    try:
        try:
            fd.write('<glidein factory_name="%s" glidein_name="%s"\n'%(factory_name,glidein_name))
            fd.write('         schedd_name="%s"\n'%string.join(schedds,','))
            fd.write('         loop_delay="60" advertise_delay="5" restart_attempts="3" restart_interval="1800">\n')
            fd.write('   <submit base_dir="%s" base_log_dir="%s" base_client_log_dir="%s" base_client_proxies_dir="%s"/>\n'%(submit_base_dir,log_base_dir,clientlog_base_dir,clientproxies_base_dir))
            fd.write('   <stage web_base_url="%s/stage" use_symlink="True" base_dir="%s/stage"/>\n'%(web_base_url,web_base_dir))
            fd.write('   <monitor base_dir="%s/monitor" javascriptRRD_dir="%s" flot_dir="%s" jquery_dir="%s"/>\n'%(web_base_dir,JAVASCRIPTRRD_PATH,FLOT_PATH,FLOT_PATH))
            # Reminder to self(Igor)
            # Would be nice if the installer allowed to provide multiple binaries
            fd.write('   <condor_tarballs>\n')
            fd.write('       <condor_tarball arch="default" os="default" base_dir="%s"/>\n'%condor_base_dir)
            fd.write('   </condor_tarballs>\n')

            # Reminder to self(Igor)
            # Add factory proxy in the config file... not reliable to use the ENV(X509_USER_PROXY)

            if voproxy_yn=="y":
                # disable factory proxy
                fd.write('   <security allow_proxy="frontend" key_length="2048" pub_key="RSA">\n')
            else:
                # allow both factory proxy and VO proxy
                fd.write('   <security allow_proxy="factory,frontend" key_length="2048" pub_key="RSA"/>n')
            fd.write('    <frontends>\n')
            for fe_name in frontends.keys():
                fd.write('     <frontend name="%s" identity="%s">\n'%(fe_name,frontends[fe_name]['id']))
                fd.write('       <security_classes>\n')
                fd.write('         <security_class name="%s" username="%s"/>\n'%(frontends[fe_name]['security_class'],frontends[fe_name]['user']))
                fd.write('       </security_classes>\n')
                fd.write('     </frontend>\n')
            fd.write('    </frontends>\n')
            fd.write('   </security>\n')
            
            fd.write('   <attrs>\n')
            if ccb_yn!="y":
                fd.write('      <attr name="USE_CCB" value="False" const="True" type="string" glidein_publish="True" publish="True" job_publish="False" parameter="True"/>\n')
                if len(gcb_list)>0:
                    fd.write('      <attr name="GCB_LIST" value="%s" const="True" type="string" glidein_publish="False" publish="False" job_publish="False" parameter="True"/>\n'%string.join(gcb_list,','))
                else:
                    fd.write('      <attr name="GCB_ORDER" value="NONE" const="True" type="string" glidein_publish="True" publish="True" job_publish="False" parameter="True"/>\n')
            else:
                # no GCB if CCB used
                fd.write('      <attr name="GCB_ORDER" value="NONE" const="True" type="string" glidein_publish="True" publish="True" job_publish="False" parameter="True"/>\n')
            fd.write('      <attr name="GLEXEC_JOB" const="True" glidein_publish="False" job_publish="False" parameter="True" publish="False" type="string" value="True"/>\n')
            fd.write('      <attr name="USE_MATCH_AUTH" value="%s" const="False" type="string" glidein_publish="False" publish="True" job_publish="False" parameter="True"/>\n'%(match_yn=='y'))
            fd.write('      <attr name="CONDOR_VERSION" const="True" glidein_publish="False" job_publish="False" parameter="True" publish="False" type="string" value="default"/>\n')
            fd.write('   </attrs>\n')
            fd.write('   <entries>\n')
            sorted_entry_names=entries_list.keys()
            sorted_entry_names.sort()
            for entry_name in sorted_entry_names:
                entry_el=entries_list[entry_name]
                if entry_el['rsl']!="":
                    rsl_str='rsl=%s'%xml.sax.saxutils.quoteattr(entry_el['rsl'])
                else:
                    rsl_str=""
                
                fd.write('      <entry name="%s" gridtype="%s" gatekeeper="%s" %s work_dir="%s">\n'%(entry_name,entry_el['gridtype'],entry_el['gatekeeper'],rsl_str,entry_el['work_dir']))
                fd.write('         <infosys_refs>\n')
                for is_el in entry_el['is_ids']:
                    fd.write('           <infosys_ref type="%s" server="%s" ref="%s"/>\n'%(is_el['type'],is_el['server'],is_el['name']))
                fd.write('         </infosys_refs>\n')
                fd.write('         <attrs>\n')
                fd.write('            <attr name="GLIDEIN_Site" value="%s" const="True" type="string" glidein_publish="True" publish="True" job_publish="True" parameter="True"/>\n'%entry_el['site_name'])
                fd.write('            <attr name="CONDOR_OS" const="True" glidein_publish="False" job_publish="False" parameter="True" publish="False" type="string" value="default"/>\n')
                fd.write('            <attr name="CONDOR_ARCH" const="True" glidein_publish="False" job_publish="False" parameter="True" publish="False" type="string" value="default"/>\n')
                if ccb_yn=="y":
                    # Put USE_CCB in the entries so that it is easy to disable it selectively
                    fd.write('            <attr name="USE_CCB" value="True" const="True" type="string" glidein_publish="True" publish="True" job_publish="False" parameter="True"/>\n')
                else:
                    # Put GCB_ORDER in the entries so that it is easy to disable it selectively
                    if len(gcb_list)>0:
                        fd.write('            <attr name="GCB_ORDER" value="RANDOM" const="False" type="string" glidein_publish="True" publish="True" job_publish="False" parameter="True"/>\n')
                fd.write('            <attr name="GLEXEC_BIN" value="%s" const="True" type="string" glidein_publish="False" publish="True" job_publish="False" parameter="True"/>\n'%entry_el['glexec_path'])
                fd.write('         </attrs>\n')
                fd.write('         <files>\n')
                fd.write('         </files>\n')
                fd.write('      </entry>\n')
            fd.write('   </entries>\n')
            fd.write('   <files>\n')
            fd.write('   </files>\n')
            fd.write('</glidein>\n')
        finally:
            fd.close()
    except:
        try:
            os.unlink(cfg_name)
        except:
            pass #just protect
        raise
        
    #####################################
    # run create_glidein

    yn=raw_input("Do you want to create the glidein (as opposed to just the config file)?: (y/n) [n]")
    if yn=='y':
        err=os.system('%s/creation/create_glidein %s'%(glideinWMS_base_dir,cfg_name))
        if err!=0:
            print "Failed to create glidein '%s'!"%glidein_name
            print "You may need to change the configuration file first"
    else:
        print "To create the glidein, you need to run"
        print '%s/creation/create_glidein %s'%(glideinWMS_base_dir,cfg_name)

    print
    print "Configuration files are located in %s/glidein_%s.cfg"%(submit_base_dir,glidein_name)
    if proxy_fname!=None:
        print "Remember to set X509_USER_PROXY before starting the daemon"
    print

    return

#-------------------------------------------------------------------------------
def extract_factory_attrs(match_str):
    glidein_attrs=[]
    attr_re=re.compile("glidein\[\"attrs\"\]\[['\"](?P<attr>[^'\"]+)['\"]\]")

    idx=0
    while 1:
        attr_obj=attr_re.search(match_str,idx)
        if attr_obj==None:
            break # not found
        attr_el=attr_obj.group('attr')
        if not (attr_el in glidein_attrs):
            glidein_attrs.append(attr_el)
        idx=attr_obj.end()+1
    return glidein_attrs
    
#-------------------------------------------------------------------------------
def extract_job_attrs(match_str):
    job_attrs=[]
    attr_re=re.compile("job\[['\"](?P<attr>[^'\"]+)['\"]\]")

    idx=0
    while 1:
        attr_obj=attr_re.search(match_str,idx)
        if attr_obj==None:
            break # not found
        attr_el=attr_obj.group('attr')
        if not (attr_el in job_attrs):
            job_attrs.append(attr_el)
        idx=attr_obj.end()+1
    return job_attrs
    
#-------------------------------------------------------------------------------
def vofrontend_install():
    global JAVASCRIPTRRD_PATH,FLOT_PATH

    if os.getuid()==0:
        print
        print "You are trying to install the VO Frontend as root"
        print "While this is possible, it is not recommended."
        print "For security reasons, it is better to install it as a non-priviledged user"
        yn=raw_input("Do you want to continue?: (y/n) ")
        if yn!='y':
            print
            print "Not installing the VO Frontend as root."
            print "Remember to install it as a regular user"
            print
            return

    print
    print "Installing VO Frontend"
    print


    glideinWMS_base_dir=os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))
    if not os.path.isdir("%s/creation"%glideinWMS_base_dir):
        raise RuntimeError,"Cannot find %s/creation"%glideinWMS_base_dir
    if not os.path.isdir("%s/frontend"%glideinWMS_base_dir):
        raise RuntimeError,"Cannot find %s/frontend"%glideinWMS_base_dir

    check_import('rrdtool')
    check_import('M2Crypto')

    if JAVASCRIPTRRD_PATH==None:
        query_javascriptRRD()

    if FLOT_PATH==None:
        query_flot()


    #################################
    # get config vals
    full_host_name=socket.getfqdn()
    fhn_arr=full_host_name.split(".")

    # Submit base directory
    def_frontstage_base_dir="%s/frontstage"%os.environ['HOME']
    frontstage_base_dir=create_empty_dir("Where will you host your config files?: ",def_frontstage_base_dir,empty_required=False)

    (web_base_dir,web_base_url)=query_WebLocation('vofrontend');

    # log base directory
    def_frontstage_log_dir="%s/frontlogs"%os.environ['HOME']
    frontstage_log_dir=create_empty_dir("Where will you host your log files?: ",def_frontstage_log_dir,empty_required=False)

    # VO Frontend name
    def_frontend_name="myVO-%s"%fhn_arr[0]
    frontend_name=raw_input("Give a name to this VO Frontend?: [%s] "%def_frontend_name)
    if frontend_name=="":
        frontend_name=def_frontend_name

    # Instance/Version name
    def_version_name="v1_0"
    while 1:
        version_name=raw_input("Give a name to this VO Frontend instance?: [%s] "%def_version_name)
        if version_name=="":
            version_name=def_version_name
        # check if dir already exists
        if os.path.exists('%s/instance_%s'%(frontstage_base_dir,version_name)):
            print "Instance '%s' already exists!"%version_name
            continue
        if os.path.exists('%s/instance_%s.cfg'%(frontstage_base_dir,version_name)):
            print "VO Frontend instance config area for '%s' already exists!"%version_name
            continue

        #have it
        break

    # WMS collector node
    print
    while 1:
        pool_node=raw_input("What node is the WMS collector (i.e. the gfactory) running?: ")
        try:
            socket.gethostbyname(pool_node.split(':')[0])
        except:
            print "'%s' not a valid host name!"%pool_node.split(':')[0]
            continue
        #have a valid pool_node
        break

    def_pool_identity="gfactory@%s"%pool_node.split(':')[0]
    pool_identity=raw_input("What is the classad identity of the glidein factory?: [%s] "%def_pool_identity)
    if pool_identity=="":
        pool_identity=def_pool_identity

    while 1:
        pool_dn=raw_input("What is the WMS collector DN (i.e. subject)?: ")
        if len(pool_dn)<5:
            print "Too short... likely invalid"
            continue
        break

    ###################################
    # Ask about the proxy
    print "\nTo use the VO Frontend you need a valid GSI proxy."
    print "VO Frontend will use this proxy to talk to the WMS Collector and User Schedd"
    while 1:
        if os.environ.has_key('X509_USER_PROXY'):
            proxy_fname=raw_input("Where is your proxy located?: [%s] "%os.environ['X509_USER_PROXY'])
            if proxy_fname=="":
                proxy_fname=os.environ['X509_USER_PROXY']
        else:
            proxy_fname=raw_input("Where is your proxy located?: ")
        proxy_fname=os.path.abspath(proxy_fname)

        if not os.path.isfile(proxy_fname):
            print "File not found: '%s'"%proxy_fname
            continue

        try:
            my_dn=get_proxy_dn(proxy_fname)
        except RuntimeError,e:
            print e
            continue
            
        break # proxy found

    print
    print "Using DN '%s'"%my_dn
    print "Make sure this DN is in the WMS collector condor_mapfile"
    print

    print "For security reasons, we need to know what will the WMS collector map us to."
    print "It will likely be something like joe@%s"%pool_node.split(':')[0]
    proxy_identity = raw_input("What is the mapped name?: ")
    print

    # collector
    
    print
    print "We are done with the WMS collector (i.e. gfactory) config"
    print "Let's not configure the access to the local (user) pool"
    print
    
    fd=os.popen("condor_config_val COLLECTOR_HOST")
    lines=fd.readlines()
    err=fd.close()
    if err!=None: # found
        default_local_collector=""
    else:
        default_local_collector=lines[0][:-1]

    main_local_collector=default_local_collector
    print "Using pool collector %s"%main_local_collector
    while 1:
        main_local_dn=raw_input("What is the pool collector DN (i.e. subject)?: ")
        if len(main_local_dn)<5:
            print "Too short... likely invalid"
            continue
        break

    print
    print "List and secondary pool collectory the glideins should use"
    print "instead of the main collector."
    print "(leave empty if you want to use the main collector only)"
    print "Valid syntaxes are:"
    print " master1.my.org:9620-9624"
    print " master1.my.org:9619"
    print " master3.my.org"
    print "Leave an empty collector name when finished."
    secondary_local_collectors=[]
    secondary_local_dns={}
    while 1:
        add_collector=raw_input("Collector name: ")
        if add_collector=="":
            break

        add_dn=raw_input("Collector DN (i.e. subject): ")
        if len(add_dn)<5:
            print "Too short... likely invalid.. retry collector %s"%add_collector
            continue

        secondary_local_collectors.append(add_collector)
        secondary_local_dns[add_collector]=add_dn


    # schedds
    fd=os.popen("condor_status -schedd -format '%s\n' Name")
    lines=fd.readlines()
    err=fd.close()
    if err!=None: # found
        raise RuntimeError, "Failed to fetch list of schedds!"

    default_schedds=[]
    for line in lines:
        line=line[:-1] #remove newline
        if line!="":
            default_schedds.append(line)

    if len(default_schedds)==0:
        raise RuntimeError, "No schedds in this pool!"

    print "The following schedds have been found:"
    for i in range(len(default_schedds)):
        print " [%i] %s"%(i+1,default_schedds[i])
    
    while 1:
        yn=raw_input("Do you want to monitor all of them?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 
        break

    if yn=="y":
        schedds=default_schedds
    else:
        print "Select the schedd indexes you want to monitor"
        print "Use a , separated list to monitor more than one"
        while 1:
            idxes=raw_input("Please select: ")
            idx_arr=idxes.split(',')
            problems=0
            for i in range(len(idx_arr)):
                try:
                    nr=int(idx_arr[i])
                    if (nr<1) or (nr>len(default_schedds)):
                        print "Index %i out of range"%nr
                        problems=1
                        break
                    idx_arr[i]=nr
                except:
                    print "'%s' is not an index!"%idx_arr[i]
                    problems=1
                    break
                
            if problems:
                continue

            schedds=[]
            for idx in idx_arr:
                schedds.append(default_schedds[idx-1])
            
            # got them
            break
    print "Using %s"%schedds
    print
    schedd_dns={}
    for schedd in schedds:
        while 1:
            schedd_dns[schedd]=raw_input("What is the DN (i.e. subject) for schedd %s?: "%schedd)
            if len(schedd_dns[schedd])<5:
                print "Too short... likely invalid"
                continue
            break
        

    # job constraint
    default_job_constraint="(JobUniverse==5)&&(GLIDEIN_Is_Monitor =!= TRUE)&&(JOB_Is_Monitor =!= TRUE)"
    job_constraint=raw_input("What kind of jobs do you want to monitor?: [%s] "%default_job_constraint)
    if job_constraint=="":
        job_constraint=default_job_constraint
                    
                    
    def_group_name="main"
    group_name=raw_input("Give a name to the main group: [%s] "%def_group_name)
    if group_name=="":
        group_name=def_group_name


    # match string
    print "What expression do you want to use to match glideins to jobs?"
    print "It is an arbitrary python boolean expression using the dictionaries"
    print "  glidein and job"
    print "A simple example expression would be:"
    print '  glidein["attrs"]["GLIDEIN_Site"] in job["DESIRED_Sites"].split(",")'
    print "If you want to match all (OK for simple setups),"
    print "  just specify True (the default)"
    
    default_match_str="True"
    match_str=raw_input("Match string: [%s] "%default_match_str)
    if match_str=="":
        match_str=default_match_str
                    
    print "What job attributres are you using in the match expression?"
    print "I have computed my best estimate for your match string,"
    print "please verify and correct if needed."
    
    default_job_attributes=string.join(extract_job_attrs(match_str),',')
    job_attributes=raw_input("Job attributes: [%s] "%default_job_attributes)
    if job_attributes=="":
        job_attributes=default_job_attributes

    if job_attributes=="":
        job_attr_list=[]
    else:
        job_attr_list=string.split(job_attributes,',')

    print "What glidein/factory attributres are you using in the match expression?"
    print "I have computed my best estimate for your match string,"
    print "please verify and correct if needed."
    
    default_factory_attributes=string.join(extract_factory_attrs(match_str),',')
    factory_attributes=raw_input("Factory attributes: [%s] "%default_factory_attributes)
    if factory_attributes=="":
        factory_attributes=default_factory_attributes

    if factory_attributes=="":
        factory_attr_list=""
    else:
        factory_attr_list=string.split(factory_attributes,',')

    #################################
    # Ask about the glidein proxies
    print "My DN = '%s'"%my_dn
    print

    glidein_proxies=[]
    glidein_proxies_dns=[]
    
    # Security setup
    while 1:
        print "VO frontend proxy = '%s'"%proxy_fname
        yn=raw_input("Do you want to use it to submit glideins: (y/n) [y] ")
        if yn=="":
            yn="y"
        elif (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 

        break
    if (yn=='y'):
        glidein_proxies.append(proxy_fname)
        glidein_proxies_dns.append(my_dn)
        


    print "You may want to use other proxies"
    print "Please add all the proxies that this glidein will use"
    print
    print "An empty entry means you are done."
    while 1:
        a_fname=raw_input("proxy fname: ")
        if a_fname=="":
            break # done

        a_fname=os.path.abspath(a_fname)
        if not os.path.isfile(a_fname):
            print "File not found: '%s'"%a_fname
            continue

        try:
            a_dn=get_proxy_dn(a_fname)
        except RuntimeError,e:
            print e
            continue

        glidein_proxies.append(a_fname)
        glidein_proxies_dns.append(a_dn)

    # USE_MATCH_AUTH
    # This way the glidein does not need to have the DNs of all the schedds
    match_yn="y"
    print
    print "Will use the more efficient Match authentication"
    print "Make sure you use Match authentication in the schedds, too"
    print

    # Expose Grid Env
    while 1:
        gridenv_yn=raw_input("Do you want to expose the Grid env. to the user jobs?: (y/n) ")
        if (gridenv_yn!="y") and (gridenv_yn!="n"):
            print "Please answer y or n"
            continue 
        break

    #####################################
    # create config dir
    os.mkdir('%s/instance_%s.cfg'%(frontstage_base_dir,version_name))
    
    #####################################
    # create config files
    cfg_name="%s/instance_%s.cfg/frontend.xml"%(frontstage_base_dir,version_name)
    fd=open(cfg_name,"w")
    try:
        try:
            fd.write('<frontend frontend_name="%s-%s">\n'%(frontend_name,version_name))
            fd.write('   <work base_dir="%s" base_log_dir="%s"/>\n'%(frontstage_base_dir,frontstage_log_dir))
            fd.write('   <stage web_base_url="%s/stage" base_dir="%s/stage"/>\n'%(web_base_url,web_base_dir))
            fd.write('   <monitor base_dir="%s/monitor" javascriptRRD_dir="%s" flot_dir="%s" jquery_dir="%s"/>\n'%(web_base_dir,JAVASCRIPTRRD_PATH,FLOT_PATH,FLOT_PATH))

            fd.write('   <collectors>\n')
            fd.write('     <collector node=%s DN=%s secondary="False"/>\n'%(xmlFormat.xml_quoteattr(main_local_collector),xmlFormat.xml_quoteattr(main_local_dn)))
            for c in secondary_local_collectors:
                fd.write('     <collector node=%s DN=%s secondary="True"/>\n'%(xmlFormat.xml_quoteattr(c),xmlFormat.xml_quoteattr(secondary_local_dns[c])))
            fd.write('   </collectors>\n')
            fd.write('   <security security_name="%s" proxy_selection_plugin="ProxyAll" classad_proxy=%s proxy_DN=%s>\n'%(frontend_name,xmlFormat.xml_quoteattr(proxy_fname),xmlFormat.xml_quoteattr(my_dn)))
            fd.write('      <proxies>\n')
            for a_fname in glidein_proxies:
                fd.write('         <proxy absfname=%s/>\n'%xmlFormat.xml_quoteattr(a_fname))
            fd.write('      </proxies>\n')
            fd.write('   </security>\n')
            fd.write('   <match>\n')
            fd.write('      <factory>\n')
            fd.write('        <collectors>\n')
            fd.write('          <collector node=%s DN=%s factory_identity=%s my_identity=%s comment="Define factory collector globally for simplicity"/>\n'%(xmlFormat.xml_quoteattr(pool_node),xmlFormat.xml_quoteattr(pool_dn),xmlFormat.xml_quoteattr(pool_identity),xmlFormat.xml_quoteattr(proxy_identity)))
            fd.write('        </collectors>\n')
            fd.write('      </factory>\n')
            fd.write('      <job query_expr=%s comment="Define job constraint and schedds globally for simplicity">\n'%xmlFormat.xml_quoteattr(job_constraint))
            fd.write('        <schedds>\n')
            for schedd in schedds:
                fd.write('         <schedd fullname=%s DN=%s/>\n'%(xmlFormat.xml_quoteattr(schedd),xmlFormat.xml_quoteattr(schedd_dns[schedd])))
            fd.write('        </schedds>\n')
            fd.write('      </job>\n')
            fd.write('   </match>\n')
            fd.write('   <attrs>\n')
            fd.write('      <attr name="GLIDEIN_Expose_Grid_Env" glidein_publish="True" job_publish="True" parameter="False" type="string" value="%s"/>\n'%(gridenv_yn=='y'))
            # this is needed for the security to work
            fd.write('      <attr name="USE_MATCH_AUTH" glidein_publish="False" job_publish="False" parameter="True" type="string" value="True"/>\n')
            # the following are just so admins know they exist
            # we put in the default values
            fd.write('      <attr name="GLIDEIN_Entry_Start" glidein_publish="False" job_publish="False" parameter="True" type="string" value="True"/>\n')
            fd.write('      <attr name="GLIDEIN_Entry_Rank" glidein_publish="False" job_publish="False" parameter="True" type="string" value="1"/>\n')
            fd.write('   </attrs>\n')
            fd.write('   <groups>\n')
            fd.write('      <group name=%s enabled="True">\n'%xmlFormat.xml_quoteattr(group_name))
            fd.write('         <match match_expr=%s>\n'%xmlFormat.xml_quoteattr(match_str))
            if len(factory_attr_list)>0:
                attr_query_arr=[]
                for job_attr in factory_attr_list:
                    attr_query_arr.append("(%s=!=UNDEFINED)"%job_attr)
                fd.write('            <factory query_expr=%s>\n'%xmlFormat.xml_quoteattr(string.join(attr_query_arr," && ")))
                fd.write('               <match_attrs>\n')
                for factory_attr in factory_attr_list:
                    fd.write('                  <match_attr name=%s type="string"/>\n'%xmlFormat.xml_quoteattr(factory_attr))
                fd.write('               </match_attrs>\n')
                fd.write('            </factory>\n')
            if len(job_attr_list)>0:
                attr_query_arr=[]
                for job_attr in job_attr_list:
                    attr_query_arr.append("(%s=!=UNDEFINED)"%job_attr)
                fd.write('            <job query_expr=%s>\n'%xmlFormat.xml_quoteattr(string.join(attr_query_arr," && ")))
                fd.write('               <match_attrs>\n')
                for job_attr in job_attr_list:
                    fd.write('                  <match_attr name=%s type="string"/>\n'%xmlFormat.xml_quoteattr(job_attr))
                fd.write('               </match_attrs>\n')
                fd.write('            </job>\n')
            fd.write('         </match>\n')
            fd.write('      </group>\n')
            fd.write('   </groups>\n')
            fd.write('   <files>\n')
            fd.write('   </files>\n')
            fd.write('</frontend>\n')
        finally:
            fd.close()
    except:
        try:
            os.unlink(cfg_name)
        except:
            pass #just protect
        raise
            

        
    #####################################
    # run create_frontend

    yn=raw_input("Do you want to create the VO Frontend instance (as opposed to just the config file)?: (y/n) [n]")
    if yn=='y':
        err=os.system('%s/creation/create_frontend %s'%(glideinWMS_base_dir,cfg_name))
        if err!=0:
            print "Failed to create VO Frontend instance '%s'!"%version_name
            print "You may need to change the configuration file first"
    else:
        print "To create the VO Frontend instance, you need to run"
        print '%s/creation/create_frontend %s'%(glideinWMS_base_dir, cfg_name)

    print
    print "Configuration file is located at %s"%cfg_name
    print

    return

##########################################
#
# Task specific procedures
#
##########################################

# Ask the user for location of directory
# and create it
########################################

def create_empty_dir(question, def_dir,empty_required=True):
    if def_dir!=None:
        question=question+("[%s] "%def_dir)
    while 1:
        user_dir=raw_input(question)
        if user_dir=="":
            user_dir=def_dir
        user_dir=os.path.abspath(user_dir)
        
        if not os.path.exists(user_dir):
            yn=raw_input("Directory '%s' does not exist, should I create it?: (y/n) "%user_dir)
            if yn!="y":
                continue #do not create, ask for a new one
            else:
                try:
                    os.mkdir(user_dir)
                except:
                    print "Failed to create '%s'!"% user_dir
                    continue
        else:
            if len(os.listdir(user_dir))!=0:
                yn='n'
                if not empty_required:
                    while 1:
                        yn=raw_input("Directory '%s' not empty.\nShould I use it anyhow?: (y/n) "% user_dir)
                        if (yn!="y") and (yn!="n"):
                            print "Please answer y or n"
                            continue 
                        break
                if empty_required or (yn!='y'):
                    print "Directory '%s' not empty!"% user_dir
                    continue

        try: # write a test file
            fd=open("%s/test.tst"%user_dir,"w")
            fd.close()
            os.unlink("%s/test.tst"%user_dir)
        except:
            print "Directory '%s' not writtable!"% user_dir
            continue
        
        return user_dir #obtained and checked the directory
 
# Ask the user where is the CA dir
########################################
def query_ca_dir():
    global GSI_TRUSTED_CA_DIR

    print "GSI security relies on a list of trusted CAs"
    print "Where can I find the directory with the trusted CAs?"
    print
    
    while 1:
        # try VDT first
        yn=raw_input("Do you want to get it from VDT?: (y/n) ")
        if yn!="n":
            return query_vdt()

        if os.environ.has_key('X509_CERT_DIR'):
            def_ca_dir=os.environ['X509_CERT_DIR']
        else:
            def_ca_dir='/etc/grid-security/certificates'

        user_dir=raw_input("Where are the trusted CAs installed?: [%s] "%def_ca_dir)
        if user_dir=='':
            user_dir=def_ca_dir
        user_dir=os.path.abspath(user_dir)
        if not os.path.isdir(user_dir):
            print "Directory '%s' does not exist"%user_dir
            continue
        if not os.path.exists("%s/1c3f2ca8.0"%user_dir):
            if not os.path.exists("%s/67e8acfa.0"%user_dir):
                print "Directory '%s' not a trusted CA area"%user_dir
                continue

        # found and verified the installation
        print "Using trusted CA dir %s"%user_dir
        print
        GSI_TRUSTED_CA_DIR=user_dir
        return

# Ask the user where is the CA dir
########################################
def query_voms_proxy_info():
    global VDT_BASE_PATH
    global VOMS_PROXY_INFO_BIN

    print "voms-proxy-info is needed to extract the VO information from the proxy"
    
    while VOMS_PROXY_INFO_BIN==None:
        if VDT_BASE_PATH==None:
            # try VDT first, if not already tried
            yn=raw_input("Do you want to get it from VDT?: (y/n) ")
            if yn!="n":
                query_vdt()
                continue

        user_bin=raw_input("Where is voms-proxy-init installed?\n(optional, leave empty if you don't have one): ")
        if user_bin=='':
            print "Not using voms-proxy-info"
            print
            VOMS_PROXY_INFO_BIN=False
            break
        
        user_bin=os.path.abspath(user_bin)
        if not os.path.isfile(user_bin):
            print "File '%s' does not exist"%user_bin
            continue

        # found and verified the installation
        print "Using %s"%user_bin
        print
        VOMS_PROXY_INFO_BIN=user_bin
        break
    return
            

# Ask the user if it has an OSG client
# Install one else
########################################
def query_vdt():
    global VDT_BASE_PATH
    global GSI_TRUSTED_CA_DIR
    global VOMS_PROXY_INFO_BIN

    # reminder
    #if os.environ.has_key('OSG_VDT_BASE'):
    #    VDT_BASE_PATH=os.environ['OSG_VDT_BASE']

    while 1:
        yn=raw_input("Do you have already a VDT installation?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 

        if yn=="y":
            if os.environ.has_key('OSG_VDT_BASE'):
                def_dir=os.environ['OSG_VDT_BASE']
                user_dir=raw_input("Where is the VDT installed?: [%s] "%def_dir)
                if user_dir=="":
                    user_dir=def_dir
            else:
                user_dir=raw_input("Where is the VDT installed?: ")
            user_dir=os.path.abspath(user_dir)
            if not os.path.isfile("%s/setup.sh"%user_dir):
                print "Directory '%s' not a VDT area (does not contain setup.sh)"%user_dir
                continue
            if not os.path.isfile("%s/globus/bin/grid-proxy-info"%user_dir):
                print "Directory '%s' not a Grid VDT area (does not contain globus/bin/grid-proxy-info)"%user_dir
                continue
            # found and verified the installation
            print "Using VDT installation in %s"%user_dir
            print
            VDT_BASE_PATH=user_dir
            break
        else:
            print
            print "This installer can install the full OSG VDT client,"
            print "or just a small, essential subset of the VDT."
            print
            print "The full OSG VDT client will provide you will all the tools you may ever need"
            print "to interact with Grid resources, but it takes a long time to install."
            print
            print "The minimal Grid VDT client will install just the bare minimum needed"
            print "to run and debug the glideinWMS instance."
            print "The minimum install packages are"
            print "PPDG-Cert-Scripts,Globus-Client,VOMS-Client,Myproxy-Client,CA-Certificates-Updater,OSG:vo-client"
            print
            yn=raw_input("Do you want to install the full OSG VDT client?: (y/n) ")
            if (yn!="y"):
                yn=raw_input("Do you want to install a minimal Grid VDT client?: (y/n) ")
                if (yn!="y"):
                    continue # do not install, ask again 
                else:
                    # install the minimal Grid VDT client
                    try:
                        install_vdt(minimal=True)
                    except RuntimeError,e:
                        print "%s"%e
                        continue # ask again
                    break
            else:
              # install OSG VDT client
              try:
                install_vdt(minimal=False)
              except RuntimeError,e:
                print "%s"%e
                continue # ask again
              break

    GSI_TRUSTED_CA_DIR="%s/globus/TRUSTED_CA"%VDT_BASE_PATH
    if os.path.isfile("%s/globus/bin/voms-proxy-info"%VDT_BASE_PATH):
        VOMS_PROXY_INFO_BIN="source %s/setup.sh;voms-proxy-info"%VDT_BASE_PATH
    return

# add a bunch of lines to crontab
###################################
def cron_append(lines,tmp_dir='/tmp'):
    tmp_fname="%s/tmp_%s_%s.tmp"%(tmp_dir,os.getpid(),time.time())
    try:
        os.system("crontab -l >%s"%tmp_fname)
        fd=open(tmp_fname,'a')
        try:
            fd.writelines(lines)
        finally:
            fd.close()
        os.system("crontab %s"%tmp_fname)
    finally:
        if os.path.isfile(tmp_fname):
            os.unlink(tmp_fname)


# Install OSG client
################################
MINIMAL_VDT_PACKAGES=['PPDG-Cert-Scripts','Globus-Client','VOMS-Client','MyProxy-Client','CA-Certificates-Updater']

def install_vdt(minimal):
    global VDT_BASE_PATH
    if os.getuid()==0:
        def_vdt_base_path="/opt/vdt"
    else:
        def_vdt_base_path="%s/vdt"%os.environ['HOME']
    
    user_dir=create_empty_dir("Where do you want the VDT installed?: ",def_vdt_base_path)

    while 1:
        default_pacman_version="3.28"
        pacman_version=raw_input("What pacman version should I use?: [%s] "%default_pacman_version)
        if pacman_version=="":
            pacman_version=default_pacman_version

        # install pacman
        err=os.system("cd %s&&wget http://vdt.cs.wisc.edu/software/pacman/%s/pacman-%s.tar.gz&&tar --no-same-owner -xzvf pacman-%s.tar.gz&&rm -f  pacman-%s.tar.gz"%(user_dir,pacman_version,pacman_version,pacman_version,pacman_version))
        if err!=0:
            print "Failed to install pacman!"
            continue
        break

    print

    if minimal:
        default_cache_location="http://vdt.cs.wisc.edu/vdt_200_cache"
        cache_location=raw_input("What VDT cache should I use?: [%s] "%default_cache_location)
        if cache_location=="":
            cache_location=default_cache_location

        package_list=[]
        for p in MINIMAL_VDT_PACKAGES:
            package_list.append("%s:%s"%(cache_location,p))
        package_list.append("http://software.grid.iu.edu/osg-1.2:vo-client")
    else:
        package_list=['http://software.grid.iu.edu/osg-1.2:client']

    # ask user about the appropriate platform
    tested_platforms=('linux-rhel-4','SL-4','linux-rhel-5','SL-5')
    print "VDT client installation tends to be very picky about the platforms it installs under"
    print "Most of the time, one needs to pretent to be one of the tested platforms"
    print "The platforms known to work are: %s"%string.join(tested_platforms,',')
    while 1:
        platform=raw_input("Which platform do you want to use (leave empty for autodetect): ")
        if platform=="":
            break # no force 
        if not (platform in tested_platforms):
            yn=raw_input("Platform '%s' is not one of the tested ones. Are you sure you want to use it?: (y/n) "%platform)
            if (yn!="y"):
                continue # not sure, reask
        # user selected a platform
        break

    if platform=="":
        platform_str=""
    else:
        platform_str="-pretend-platform %s"%platform
    print
    print "The VDT installation will start in a moment."
    print "CA certificates are installed as part of this procedure; ignore the VDT warning message."
    if not minimal:
        print "Please do not enable Condor, as we will install it separatelly."
    time.sleep(2)
    print

    # install the VDT client
    err=os.system("cd %s/pacman-%s;source setup.sh;cd %s&&pacman -trust-all-caches %s -get %s"%(user_dir,pacman_version,user_dir,platform_str,' '.join(package_list)))
    if err!=0:
        raise RuntimeError,"Failed to install the VDT client!"
    
    # remove the condor component
    # ignore any error
    if not minimal:
        os.system("cd %s/pacman-%s;source setup.sh;cd %s&&pacman -remove Condor >/dev/null"%(user_dir,pacman_version,user_dir))

    # initialize CA CRL config
    print "VDT does not provide a default URL for CA fetching"
    print "You need to provide one"
    default_crl_url="http://software.grid.iu.edu/pacman/cadist/ca-certs-version"
    print "The default OSG location is: %s"%default_crl_url
    crl_url=raw_input("Where should I fetch the CAs from?: [%s] "%default_crl_url)
    if crl_url=="":
        crl_url=default_crl_url

    err=os.system("cd %s;source setup.sh; vdt-ca-manage setupca --location local --url %s"%(user_dir, crl_url))
    if err!=0:
        raise RuntimeError,"Failed to initalize the CAs!"

    # initialize the VDT client
    if os.getuid()==0:
        # automatic if root
        err=os.system("cd %s;source setup.sh;vdt-control --enable vdt-update-certs;vdt-control --enable fetch-crl;vdt-control --enable vdt-rotate-logs;vdt-control --on"%user_dir)
        if err!=0:
            raise RuntimeError,"Failed to initalize the VDT client!"
    else:
        # else need to do it by hand
        # make VDT create the template
        err=os.system("cd %s;source setup.sh;vdt-register-service --enable --name fetch-crl&&vdt-register-service --enable --name vdt-rotate-logs&&vdt-register-service --enable --name vdt-update-certs"%user_dir)
        if err!=0:
            raise RuntimeError,"Failed to initalize the VDT client!"

        # extract the lines to put in cron
        fd=open("%s/vdt/services/state"%user_dir,'r')
        try:
            lines=fd.readlines()
        finally:
            fd.close()

        cron_lines=[]
        for line in lines:
            els=line.split(None,9)
            if len(els)!=10:
                continue # ignore, not a good line
            if (els[1]!='cron') or (els[2]!='enable'):
                continue # not a cron line
            cron_lines.append(string.join(els[4:]))
            # also run it once by hand
            print "Initializing %s"%els[0]
            os.system(els[9])

        # add them to cron
        print "Adding %i lines to crontab"%len(cron_lines)
        cron_append(cron_lines,tmp_dir=user_dir)
        print
        
    if os.getuid()==0: # different if root or not
        # as root
        yn=raw_input("Do you want OSG_VDT_BASE defined globally?: (y/n) ")
        if yn!="n":
            # put rrd binaries in system wide path
            fd=open("/etc/profile.d/osg_vdt.sh","w")
            try:
                fd.write("export OSG_VDT_BASE=%s\n"%user_dir)
                fd.write("export X509_CERT_DIR=$OSG_VDT_BASE/globus/TRUSTED_CA\n")
            finally:
                fd.close()
            os.chmod("/etc/profile.d/osg_vdt.sh",
                     stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

            fd=open("/etc/profile.d/osg_vdt.csh","w")
            try:
                fd.write("setenv OSG_VDT_BASE %s\n"%user_dir)
                fd.write("setenv X509_CERT_DIR $OSG_VDT_BASE/globus/TRUSTED_CA\n")
            finally:
                fd.close()
            os.chmod("/etc/profile.d/osg_vdt.csh",
                     stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)
    else:
        # as regular user
        yn=raw_input("Do you want OSG_VDT_BASE in you home dir config?: (y/n) ")
        if yn!="n":        
            # put rrd path in .profile
            fd=open("%s/.profile"%os.environ['HOME'],"a")
            try:
                fd.write("\n# OSG vdt client settings\n")
                fd.write("export OSG_VDT_BASE=%s\n"%user_dir)
                fd.write("export X509_CERT_DIR=$OSG_VDT_BASE/globus/TRUSTED_CA\n")
            finally:
                fd.close()

            fd=open("%s/.bashrc"%os.environ['HOME'],"a")
            try:
                fd.write("\n# OSG vdt client settings\n")
                fd.write("export OSG_VDT_BASE=%s\n"%user_dir)
                fd.write("export X509_CERT_DIR=$OSG_VDT_BASE/globus/TRUSTED_CA\n")
            finally:
                fd.close()

            # and in .cshrc
            fd=open("%s/.cshrc"%os.environ['HOME'],"a")
            try:
                fd.write("\n# OSG vdt client settings\n")
                fd.write("setenv OSG_VDT_BASE %s\n"%user_dir)
                fd.write("setenv X509_CERT_DIR $OSG_VDT_BASE/globus/TRUSTED_CA\n")
            finally:
                fd.close()

    # everything went well, register
    print
    print "VDT client installed"
    print
    
    VDT_BASE_PATH=user_dir
    return

# Create /etc/init.d/condor
# startup script
################################

def create_condor_initd(fname='/etc/init.d/condor',user_condor_base_dir=None):
    if user_condor_base_dir==None:
        raise RuntimeError,"user_condor_base_dir not defined!"
    
    ##################################################
    # init.d file for authomated startup and shutdown
    fd=open(fname,"w")
    try:
        fd.write("#!/bin/bash\n")
        fd.write("# condor   This is the Condor batch system\n")
        fd.write("# chkconfig: 35 90 30\n")
        fd.write("# description: Starts and stops Condor\n\n")
        
        fd.write("# Source function library.\n")
        fd.write("if [ -f /etc/init.d/functions ] ; then\n")
        fd.write("        . /etc/init.d/functions\n")
        fd.write("elif [ -f /etc/rc.d/init.d/functions ] ; then\n")
        fd.write("        . /etc/rc.d/init.d/functions\n")
        fd.write("else\n")
        fd.write("        exit 0\n")
        fd.write("fi\n\n")
        
        fd.write("start() {\n")
        fd.write('        echo -n "Starting condor: "\n')
        fd.write("        %s/start_condor.sh 2>/dev/null 1>&2 && success || failure\n"%user_condor_base_dir)
        fd.write("        RETVAL=$?\n")
        fd.write("        echo\n")
        fd.write("}\n\n")
        
        fd.write("stop() {\n")
        fd.write('        echo -n "Shutting down condor: "\n')
        fd.write("        killall -q -9 condor_master condor_schedd condor_shadow condor_collector condor_negotiator condor_procd condor_gridmanager gahp_server 2>/dev/null 1>&2\n")
        fd.write("        sleep 1\n")
        fd.write("        # If a master is still alive, we have a problem\n")
        fd.write("        killall condor_master 2>/dev/null 1>&2 && failure || success\n")
        fd.write("        RETVAL=$?\n")
        fd.write("        echo\n")
        fd.write("}\n\n")
        
        fd.write("restart() {\n")
        fd.write("        stop\n")
        fd.write("        start\n")
        fd.write("}\n\n")
        
        fd.write("case $1 in\n")
        fd.write("        start)\n")
        fd.write("                start\n")
        fd.write("        ;;\n")
        fd.write("        stop)\n")
        fd.write("                stop\n")
        fd.write("        ;;\n")
        fd.write("        restart)\n")
        fd.write("                restart\n")
        fd.write("        ;;\n")
        fd.write("        status)\n")
        fd.write("                status %s/sbin/condor_master\n"%user_condor_base_dir)
        fd.write("        ;;\n")
        fd.write("        *)\n")
        fd.write('        echo $"Usage: $prog {start|stop|restart|status}"\n')
        fd.write("        exit 1\n")
        fd.write("esac\n\n")
        
        fd.write("exit $RETVAL\n")
    finally:
        fd.close()
    os.chmod(fname,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

# Install Condor from tarball
# and run condor_configure
################################

def install_condor():
    global CONDOR_BASE_PATH
    global CONDOR_USER
    global CONDOR_IDS
    global CONDOR_LOCAL_DIR
    global CONDOR_UPD_CONFIG_FILE
    user = []

    print "Installing condor"
    print

    ################################
    # Ask which user should run condor
    # and verify it
    if os.getuid()==0:
        # only root can change UID
        def_condor_user="condor"
        while 1:
            condor_user=raw_input("Which user should Condor run under?: [%s] "%def_condor_user)
            if condor_user=="":
                condor_user=def_condor_user
            try:
                pwd.getpwnam(condor_user)
            except:
                print "User '%s' does not exist. Either create it or specify a different user."%condor_user
                continue
            break # got and verified the user
        CONDOR_USER=condor_user
        user = pwd.getpwnam(condor_user)
    else:
        CONDOR_USER=pwd.getpwuid(os.getuid())[0]
        user = pwd.getpwuid(os.getuid()) 
    CONDOR_IDS = "%s.%s" % (user[2],user[3])


    ################################
    # Ask for the condor tarball
    # and verify it

    while 1:
        print
        print "You will now need the Condor tarball"
        print "You can find it on http://www.cs.wisc.edu/condor/"
        print "Versions v7.2.2 and 7.3.1 have been tested, but you"
        print "should always use the latest one"
        print
        condor_tarball=raw_input("Where do you have the Condor tarball? ")
        if not os.path.isfile(condor_tarball):
            print "File '%s' not found!"%condor_tarball
            continue

        print "Checking..."

        try:
            fd=tarfile.open(condor_tarball,"r:gz")
        except:
            print "File '%s' not a valid tar.gz file!"%condor_tarball
            continue

        try:
            try:
                first_dir=fd.getnames()[0]
                if (first_dir[:7]!="condor-") or (first_dir[-1]!='/'):
                    print "File '%s' is not a condor tarball! (found '%s', expected 'condor-*/'"%(condor_tarball,first_dir)
                    continue
                condor_version=first_dir[7:-1]
                print "Seems condor version %s"%condor_version
                try:
                    fd.getmember(first_dir+"condor_configure")
                except:
                    print "Filename '%s' missing %s!"%(condor_tarball,first_dir+"condor_configure")
                    continue
                break; # found and verified it
            except:
                print "File '%s' corrupted!"%condor_tarball
                continue
        finally:
            fd.close()
    print

    ################################
    # Ask for the install dir
    # and verify it

    if os.getuid()==0:
        def_condor_base_dir="/opt/glidecondor"
    else:
        def_condor_base_dir="%s/glidecondor"%os.environ['HOME']
    
    user_condor_base_dir=create_empty_dir("Where do you want to install it?: ",def_condor_base_dir)
    tar_dir="%s/tar"%user_condor_base_dir
    os.mkdir(tar_dir)
    print "Installing condor in '%s'"%user_condor_base_dir
    print
    
    ################################
    # Ask for admin email

    while 1:
        admin_email=raw_input("If something goes wrong with Condor, who should get email about it?: ")
        if admin_email.find('@')<0:
            print "'%s' is not a valid email address!"%admin_email
            continue
        break #found and verified

    ################################
    # Do the actual installation
    # Hard fail if anything goes wrong

    try:
        print "Extracting from tarball"
        fd=tarfile.open(condor_tarball,"r:gz")
        # first create the regular files
        for f in fd.getmembers():
            if not f.islnk():
                fd.extract(f,tar_dir)
        # then create the links
        for f in fd.getmembers():
            if f.islnk():
                os.link(os.path.join(tar_dir,f.linkname),os.path.join(tar_dir,f.name))
        fd.close()
    
        print "Running condor_configure"
        CONDOR_LOCAL_DIR="%s/condor_local"%user_condor_base_dir
        install_str="%s/condor-%s/release.tar"%(tar_dir,condor_version)
        if not os.path.isfile(install_str):
            # Condor v7 changed the packaging
            install_str="%s/condor-%s"%(tar_dir,condor_version)

        cmdline="cd %s/condor-%s;./condor_configure --install=%s --install-dir=%s --local-dir=%s --install-log=%s/condor_configure.log"%(tar_dir,condor_version,install_str,user_condor_base_dir,CONDOR_LOCAL_DIR,tar_dir)
        if os.getuid()==0:
            cmdline="%s  --owner=%s"%(cmdline,condor_user)
            
        err=os.system(cmdline)
        if err!=0:
            raise RuntimeError,"condor_configure failed! (%i)"%err
    finally:
        # installation files not needed anymore
        shutil.rmtree(tar_dir)

    yn=raw_input("Do you want to split the config files between condor_config and condor_config.local?: (y/n) [y] ")
    if yn!='n':
      CONDOR_UPD_CONFIG_FILE="%s/etc/condor_config.local"%user_condor_base_dir
      config_fd=open("%s/etc/condor_config"%user_condor_base_dir,"a")
      try:
        config_fd.write("\n########################################################\n")
        config_fd.write("# will use etc/condor_config.local \n")
        config_fd.write("########################################################\n")
        config_fd.write("LOCAL_CONFIG_FILE = %s\n"%CONDOR_UPD_CONFIG_FILE)
      finally:
        config_fd.close()
    else: # else always update the main one
      CONDOR_UPD_CONFIG_FILE="%s/etc/condor_config"%user_condor_base_dir
      config_fd=open("%s/etc/condor_config"%user_condor_base_dir,"a")
      try:
        config_fd.write("\n########################################################\n")
        config_fd.write("# disable additional config files \n")
        config_fd.write("########################################################\n")
        config_fd.write("LOCAL_CONFIG_FILE = \n")
      finally:
        config_fd.close()


    ##################################################
    # Append condor_config.local to main condor_config
    # leave condor_config.local empty

    local_fd=open("%s/condor_local/condor_config.local"%user_condor_base_dir,"r")
    try:
        local_lines=local_fd.readlines()
    finally:
        local_fd.close()

    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n########################################################\n")
        config_fd.write("# Whatever condor_configure put into condor_config.local\n")
        config_fd.write("########################################################\n\n")
        config_fd.writelines(local_lines)
    finally:
        config_fd.close()

    # empty official condor_config.local
    local_fd=open("%s/condor_local/condor_config.local"%user_condor_base_dir,"w")
    local_fd.write("\n### Not Used ###\n")
    local_fd.close()

    ##################################################
    # Configure values condor_configure does not
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("# Base configuration values for glideinWMS\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("##  When something goes wrong with condor at your site, who should get the email?\n")
        config_fd.write("CONDOR_ADMIN = %s\n\n"%admin_email)
        config_fd.write("##  With glideins, there is nothing shared\n")
        config_fd.write("UID_DOMAIN=$(FULL_HOSTNAME)\nFILESYSTEM_DOMAIN=$(FULL_HOSTNAME)\n\n")
        config_fd.write("##  Condor needs to create a few lock files to synchronize access to various log files\n")
        config_fd.write("##  Use the log directory so they are collocated\n")
        config_fd.write("LOCK = $(LOG)\n\n")
        config_fd.write("############################################################\n")
        config_fd.write("## Security config\n")
        config_fd.write("############################################################\n\n")
        config_fd.write("############################\n")
        config_fd.write("# Authentication settings\n")
        config_fd.write("############################\n")
        config_fd.write("SEC_DEFAULT_AUTHENTICATION = REQUIRED\n")
        config_fd.write("SEC_DEFAULT_AUTHENTICATION_METHODS = FS\n")
        config_fd.write("SEC_READ_AUTHENTICATION = OPTIONAL\n")
        config_fd.write("SEC_CLIENT_AUTHENTICATION = OPTIONAL\n\n")
        config_fd.write("############################\n")
        config_fd.write("# Privacy settings\n")
        config_fd.write("############################\n")
        config_fd.write("SEC_DEFAULT_ENCRYPTION = OPTIONAL\n")
        config_fd.write("SEC_DEFAULT_INTEGRITY = REQUIRED\n")
        config_fd.write("SEC_READ_INTEGRITY = OPTIONAL\n")
        config_fd.write("SEC_CLIENT_INTEGRITY = OPTIONAL\n")
        config_fd.write("SEC_READ_ENCRYPTION = OPTIONAL\n")
        config_fd.write("SEC_CLIENT_ENCRYPTION = OPTIONAL\n\n")
        config_fd.write("##  Without strong security, the only secure connection is the local one\n")
        config_fd.write("HOSTALLOW_WRITE = $(FULL_HOSTNAME)\n\n")
        config_fd.write("ALLOW_WRITE = $(HOSTALLOW_WRITE)\n\n")
    finally:
        config_fd.close()

    ##################################################
    # Put condor in path
    if os.getuid()==0: # different if root or not
        # as root

        #########################################
        # Put link into /etc/condor/condor_config
        if not os.path.exists('/etc/condor'):
            os.mkdir('/etc/condor')
        if os.path.islink('/etc/condor/condor_config') or os.path.exists('/etc/condor/condor_config'):
            # an old version exists... replace
            os.unlink('/etc/condor/condor_config')
        os.symlink("%s/etc/condor_config"%user_condor_base_dir,'/etc/condor/condor_config')

        #########################################
        # put condor binaries in system wide path
        fd=open("/etc/profile.d/condor.sh","w")
        try:
            fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%user_condor_base_dir)
            fd.write("  PATH=${PATH}:%s/bin\n"%user_condor_base_dir)
            fd.write("fi\n")
        finally:
            fd.close()
        os.chmod("/etc/profile.d/condor.sh",
                 stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

        fd=open("/etc/profile.d/condor.csh","w")
        try:
            fd.write("set path = ( $path %s/bin )\n"%user_condor_base_dir)
        finally:
            fd.close()
        os.chmod("/etc/profile.d/condor.csh",
                 stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    else:
        # as regular user

        #########################################
        # put condor config in .profile
        fd=open("%s/.profile"%os.environ['HOME'],"a")
        try:
            fd.write("\n# Condor settings\n")
            fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%user_condor_base_dir)
            fd.write("  export PATH=%s/bin:${PATH}\n"%user_condor_base_dir)
            fd.write("  export CONDOR_CONFIG=%s/etc/condor_config\n"%user_condor_base_dir)
            fd.write("fi\n\n")
        finally:
            fd.close()
        
        fd=open("%s/.bashrc"%os.environ['HOME'],"a")
        try:
            fd.write("\n# Condor settings\n")
            fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%user_condor_base_dir)
            fd.write("  export PATH=%s/bin:${PATH}\n"%user_condor_base_dir)
            fd.write("  export CONDOR_CONFIG=%s/etc/condor_config\n"%user_condor_base_dir)
            fd.write("fi\n\n")
        finally:
            fd.close()
        
        # and in .cshrc
        fd=open("%s/.cshrc"%os.environ['HOME'],"a")
        try:
            fd.write("\n# Condor settings\n")
            fd.write("set path = ( %s/bin $path)\n"%user_condor_base_dir)
            fd.write("setenv CONDOR_CONFIG %s/etc/condor_config\n\n"%user_condor_base_dir)
        finally:
            fd.close()

        # put condor config in the path for the rest of the installation
        os.environ['CONDOR_CONFIG']="%s/etc/condor_config"%user_condor_base_dir
        if os.environ.has_key('PATH'):
            os.environ['PATH']="%s/bin:%s"%(user_condor_base_dir,os.environ['PATH'])
        else:
            os.environ['PATH']="%s/bin:"%user_condor_base_dir

        print
        print "The Condor config has been put in your login files"
        print "Please remember to exit and reenter the terminal after the install"
        print
        

    ##########################################
    # Put condor binaries in the process path
    if os.environ.has_key('PATH'):
        os.environ['PATH']="%s/bin:%s"%(user_condor_base_dir,os.environ['PATH'])
    else:
        os.environ['PATH']="%s/bin:"%user_condor_base_dir
    
    ##########################################
    # Node wide startup file
    # Will have only primary master for now
    # Any other must be added by someone else
    fd=open("%s/start_condor.sh"%user_condor_base_dir,"w")
    try:
        fd.write("#!/bin/sh\n")
        fd.write("%s/sbin/condor_master\n"%user_condor_base_dir)
        fd.write("sleep 1\n")
    finally:
        fd.close()
    os.chmod("%s/start_condor.sh"%user_condor_base_dir,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    if os.getuid()==0:
        create_condor_initd('/etc/init.d/condor',user_condor_base_dir)

    ##################################################
    # Condor installed, register it
    CONDOR_BASE_PATH = user_condor_base_dir
    print "Condor installed"
    print
    return

def restart_condor():
    global CONDOR_USER
    global CONDOR_BASE_PATH

    print
    print "Restarting Condor"
    print

    # try to kill old condor daemons, if any
    os.system("pkill -9 -u %s 'condor_.*'"%CONDOR_USER)

    # start condor daemons
    err=os.system("%s/start_condor.sh"%CONDOR_BASE_PATH)
    if err!=0:
        raise RuntimeError, "Failed to start Condor"
    return

# Extact x509 info
################################
def get_proxy_dn(proxy_fname):
    return get_cert_dn(proxy_fname,type_text='proxy')

def get_cert_dn(cert_fname,type_text='certificate'):
    if not os.path.isfile(cert_fname):
        raise RuntimeError,"File '%s' not found"%cert_fname

    #extract DN
    dn_fd=os.popen("openssl x509 -subject -in %s -out /dev/null"%cert_fname)
    dn_blob=dn_fd.read()
    err=dn_fd.close()
    if err!=None:
        raise RuntimeError,"Failed to extract DN from certificate '%s'!"%cert_fname

    i=dn_blob.find("subject= ")
    if i<0:
        raise RuntimeError,"Failed to extract Subject from certificate '%s'!"%cert_fname

    dn_blob=dn_blob[i+9:] # remove part before subject
    my_dn=dn_blob[:dn_blob.find('\n')] # keep only the part until the newline

    # remove the proxy part
    while my_dn[-9:]=='/CN=proxy':
        my_dn=my_dn[:-9]

    return my_dn

# if cannnot get one, returns None
def get_proxy_vo(proxy_fname):
    global VOMS_PROXY_INFO_BIN

    if not os.path.isfile(proxy_fname):
        raise RuntimeError,"Proxy '%s' not found"%proxy_fname

    if VOMS_PROXY_INFO_BIN==None:
        query_voms_proxy_info()
        
    if VOMS_PROXY_INFO_BIN==False:
        return None # User said he does not have voms-proxy-info
    
    #extract VO
    vo_fd=os.popen("%s -all -file %s"%(VOMS_PROXY_INFO_BIN,proxy_fname))
    vo_blob=vo_fd.read()
    err=vo_fd.close()
    #if err!=None:
    #    raise RuntimeError,"Failed to extract VO from proxy '%s'!"%proxy_fname

    i=vo_blob.find("VO        : ")
    if i<0:
        return None # proxy did not have VOMS extension

    vo_blob=vo_blob[i+12:] # remove part before VO
    my_vo=vo_blob[:vo_blob.find('\n')] # keep only the part until the newline
            
    return my_vo

# Update condor config with
# GSI security
################################
def configure_gsi_security(gsi_setup=None):
    global CONDOR_BASE_PATH
    global GSI_TRUSTED_CA_DIR
    global GSI_SECURITY_CONFIGURED
    global CONDOR_UPD_CONFIG_FILE

    print "Configuring GSI security"
    print

    if GSI_TRUSTED_CA_DIR==None:
        query_ca_dir()

    
    #################################
    # Useful to make user understand 
    # the gsi setup
    server = ""
    client = ""
    server_comment = ""
    client_comment = ""
    if (gsi_setup != None):
        server = gsi_setup['server']
        client = gsi_setup['client']
        server_comment = gsi_setup['server_comment']
        client_comment = gsi_setup['client_comment']


    #################################
    # Create security support directory 
    os.mkdir("%s/certs"%CONDOR_BASE_PATH)

    #################################
    # Ask if uses proxy or cert
    # and verify
    print "To use the GSI security for %s, you either need "%server
    print "a valid GSI proxy or a valid x509 certificate and relative key."
    print "%s\n" % server_comment
    while 1:
        pc=raw_input("Will you be using a proxy or a cert? (proxy/cert) ")
        if (pc!="proxy") and (pc!="cert"):
            print "Please select either proxy or cert"
            continue

        if pc=="proxy":
            proxy_fname=raw_input("Where is your proxy located?: ")
            proxy_fname=os.path.abspath(proxy_fname)
            
            try:
                my_dn=get_proxy_dn(proxy_fname)
                use_proxy=1
            except RuntimeError,e:
                print e
                continue
            
            break # proxy found
        else:
            cert_fname=raw_input("Where is your certificate located?: ")
            cert_fname=os.path.abspath(cert_fname)
            if not os.path.isfile(cert_fname):
                print "Certificate '%s' not found"%cert_fname
                continue
            cert_keyname=raw_input("Where is your certificate key located?: ")
            cert_keyname=os.path.abspath(cert_keyname)
            if not os.path.isfile(cert_keyname):
                print "Certificate key '%s' not found"%cert_keyname
                continue

            try:
                my_dn=get_cert_dn(cert_fname)
                use_proxy=0
            except RuntimeError,e:
                print e
                continue

            break # cert and key found
            
    print "My DN = '%s'"%my_dn
    print

    #################################
    # create condor_mapfile
    # ask user for additional DNs
    dns={"condor":[my_dn,True]}
    print "You will most probably need other DNs in the condor grid mapfile."
    print "%s\n" % client_comment
    print "Please insert all such DNs, together with a user nickname."
    print "An empty DN entry means you are done."
    while 1:
        a_dn=raw_input("DN: ")
        if a_dn=="":
            break # done
        default_uid="condor%03i"%len(dns.keys())
        a_uid=raw_input("nickname: [%s] "%default_uid)
        if a_uid=="":
            a_uid=default_uid
        if a_uid.find(" ")>=0:
            print "WARNING: Nickname cannot contain spaces ('%s'), please reinsert the DN with a different nickname."%a_uid
            continue
        if a_uid in dns.keys():
            print "WARNING: Cannot reuse '%s', please reinsert the DN with a different nickname."%a_uid
            continue
        while 1:
            yn=raw_input("Is this a trusted Condor daemon?: (y/n) ")
            if (yn!="y") and (yn!="n"):
                print "Please answer y or n"
                continue 
            break
        dns[a_uid]=[a_dn,yn=='y']


    # create the condor_mapfile
    condor_mapfile="%s/certs/condor_mapfile"%CONDOR_BASE_PATH
    gridmap_fd=open(condor_mapfile,"w")
    try:
        for a_uid in dns.keys():
            gridmap_fd.write('GSI "^%s$" %s\n'%(re.escape(dns[a_uid][0]),a_uid))
        gridmap_fd.write('GSI (.*) anonymous\n')
        gridmap_fd.write('FS (.*) \\1\n')
    finally:
        gridmap_fd.close()

    #################################
    # do the config
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("############################################################\n")
        config_fd.write("## GSI Security config\n")
        config_fd.write("############################################################\n\n")
        config_fd.write("############################\n")
        config_fd.write("# Authentication settings\n")
        config_fd.write("############################\n")
        config_fd.write("SEC_DEFAULT_AUTHENTICATION_METHODS = FS,GSI\n")
        config_fd.write("DENY_WRITE = anonymous@*\n")
        config_fd.write("DENY_ADMINISTRATOR = anonymous@*\n")
        config_fd.write("DENY_DAEMON = anonymous@*\n")
        config_fd.write("DENY_NEGOTIATOR = anonymous@*\n\n")
        config_fd.write("DENY_CLIENT = anonymous@*\n")
        config_fd.write("# Grid Certificate directory\n")
        config_fd.write("GSI_DAEMON_TRUSTED_CA_DIR=%s\n\n"%GSI_TRUSTED_CA_DIR)
        config_fd.write("############################\n")
        config_fd.write("# Set daemon cert location\n")
        config_fd.write("############################\n")
        config_fd.write("GSI_DAEMON_DIRECTORY = %s/certs\n\n"%CONDOR_BASE_PATH)
        config_fd.write("############################\n")
        config_fd.write("# Credentials\n")
        config_fd.write("############################\n")
        if use_proxy:
            config_fd.write("GSI_DAEMON_PROXY = %s\n\n"%proxy_fname)
            config_fd.write("# If you ever decide to use a Certificate, see below\n")
            config_fd.write("#GSI_DAEMON_CERT = /etc/grid-security/hostcert.pem\n")
            config_fd.write("#GSI_DAEMON_KEY  = /etc/grid-security/hostkey.pem\n\n")
        else:
            config_fd.write("GSI_DAEMON_CERT = %s\n"%cert_fname)
            config_fd.write("GSI_DAEMON_KEY  = %s\n\n"%cert_keyname)
            config_fd.write("# If you ever decide to use a Proxy, see below\n")
            config_fd.write("#GSI_DAEMON_PROXY = $(GSI_DAEMON_DIRECTORY)/x509_service_proxy\n\n")

        config_fd.write("#################################\n")
        config_fd.write("# Where to find ID->uid mappings\n")
        config_fd.write("#################################\n")
        config_fd.write("CERTIFICATE_MAPFILE=%s\n\n"%condor_mapfile)

        config_fd.write("#####################################\n")
        config_fd.write("# Add whitelist of condor daemon DNs\n")
        config_fd.write("#####################################\n")
        config_fd.write("# My DN\n")
        config_fd.write("GSI_DAEMON_NAME=%s\n"%dns['condor'][0])
        config_fd.write("# DNs of other trusted daemons provided at installation time\n")
        for a_uid in dns.keys():
            a_dn,is_daemon=dns[a_uid]
            if (a_uid!='condor') and is_daemon:
                config_fd.write("# The following DN will map to %s\n"%a_uid)
                config_fd.write("GSI_DAEMON_NAME=$(GSI_DAEMON_NAME),%s\n"%a_dn)

        config_fd.write("\n#####################################\n")
        config_fd.write("# Limit session caching to ~12h\n")
        config_fd.write("#####################################\n")
        config_fd.write("SEC_DAEMON_SESSION_DURATION = 50000\n")


        config_fd.write("#####################################################\n")
        config_fd.write("# With strong security, do not use IP based controls\n")
        config_fd.write("#####################################################\n")
        config_fd.write("HOSTALLOW_WRITE = *\n\n")
        config_fd.write("ALLOW_WRITE = $(HOSTALLOW_WRITE)\n\n")

        config_fd.write("##########################################################\n")
        config_fd.write("# Prepare the Shadow for use with glexec-enabled glideins\n")
        config_fd.write("##########################################################\n")
        config_fd.write("SHADOW.GLEXEC_STARTER = True\n")
        config_fd.write("SHADOW.GLEXEC = /bin/false\n\n")
    finally:
        config_fd.close()


    #################################
    #GSI security configured
    GSI_SECURITY_CONFIGURED=1
    return

# Configure Condor Privsep
######################################
def setup_privsep():
    global CONDOR_BASE_PATH
    global PRIVSEP_INSTALLED
    global CONDOR_UPD_CONFIG_FILE

    if os.getuid()!=0:
        raise RuntimeError, "Privsep can only be installed as root! Not doing anything!"

    print "Privilege separation is needed to securely support multiple frontends."
    yn=raw_input("Do you want to install it?: (y/n) [y]")
    if yn=='n':
        # nothing to be done
        return

    switchboard_bin=os.path.join(CONDOR_BASE_PATH,'sbin/condor_root_switchboard')
    if os.stat(switchboard_bin)[stat.ST_UID]!=0:
        raise RuntimeError, "Privsep binary (%s) not owned by root! Not doing anything!"%switchboard_bin

    if not os.path.exists('/etc/condor'):
        # Condor may have been installed in a different way
        # But provsep is hardwired to look in this dir
        os.mkdir('/etc/condor')

    create_config=True
    if os.path.exists('/etc/condor/privsep_config'):
        create_config=False
        while 1:
            overwrite_yn=raw_input("A privsep config (/etc/condor/privsep_config) is already in place. Do you want to recreate it?: (y/n) ")
            if (overwrite_yn!="y") and (overwrite_yn!="n"):
                print "Please answer y or n"
                continue 
            break
        if overwrite_yn=='y':
            create_config=True
        else:
            while 1:
                reuse_yn=raw_input("Do you want to just use the content of the current privsep config?: (y/n) ")
                if (reuse_yn!="y") and (reuse_yn!="n"):
                    print "Please answer y or n"
                    continue 
                break
            if reuse_yn=='n':
                # you choose to not proceed futher
                raise RuntimeError, "An old privsep config (/etc/condor/privsep_config) found! Not doing anything!"
    

    while 1:
        factory_user=raw_input("What is the factory username: ")

        try:
            factory_group=grp.getgrgid(pwd.getpwnam(factory_user)[3])[0]
            user_valid=True
        except KeyError:
            user_valid=False

        if not user_valid:
            print "User '%s' does not exist. If it is not a typo, please create it and retry."
            continue
        break

    if create_config:
        groups={}
        users=[]
        print
        print "List the usernames the factroy will use"
        print "to separate frontends from one another."
        print "An empty username entry means you are done."
        while 1:
            user=raw_input("Username: ")
            if user=='':
                break #done

            try:
                group=grp.getgrgid(pwd.getpwnam(user)[3])[0]
                user_valid=True
            except KeyError:
                user_valid=False

            if not user_valid:
                print "User '%s' does not exist. If it is not a typo, please create it and retry."
                continue

            if not groups.has_key(group):
                groups[group]=[]

            # we may have multiple users sharing the same group, so group them together
            groups[group].append(user)
            users.append(user)

        print
        print "Directories needed by the factory will be given special"
        print "treatment to ease administration."
        submit_base_dir=create_empty_dir('Where will the factory store its config files?','/var/gfactory/glideinsubmit',False)
        os.chown(submit_base_dir,pwd.getpwnam(factory_user)[2],pwd.getpwnam(factory_user)[3])
        
        log_base_dir=create_empty_dir('Where will the factory store its log files?','/var/gfactory/glideinlogs',False)
        os.chown(log_base_dir,pwd.getpwnam(factory_user)[2],pwd.getpwnam(factory_user)[3])
        
        userlog_dir=create_empty_dir('Where will the factory store the client log files?','/var/gfactory/clientlogs',False)
        userproxy_dir=create_empty_dir('Where will the factory store the client proxies?','/var/gfactory/clientproxies',False)

        fd=open('/etc/condor/privsep_config','w')
        try:
            fd.write('valid-caller-uids = %s\n'%factory_user)
            fd.write('valid-caller-gids = %s\n'%factory_group)
            fd.write('valid-target-uids = %s\n'%string.join(users,' : '))
            fd.write('valid-target-gids = %s\n'%string.join(groups.keys(),' : '))
            fd.write('valid-dirs = %s\n'%userlog_dir)
            fd.write('valid-dirs = %s\n'%userproxy_dir)
            fd.write('procd-executable = %s\n'%os.path.join(CONDOR_BASE_PATH,'sbin/condor_procd'))
        finally:
            fd.close()
        

    # finally set the setuid bit
    os.chmod(switchboard_bin,04755)

    ########################################
    # Make factory user a condor superuser
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## Make the factory user a condor superuser\n")
        config_fd.write("## This is needed by the factory damemons in privsep mode\n")
        config_fd.write("##  and it also makes the administration easier\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("QUEUE_SUPER_USERS = $(QUEUE_SUPER_USERS), %s\n"%factory_user)
    finally:
        config_fd.close()

    print
    print "Privilege separation setup completed"
    print
    
    PRIVSEP_INSTALLED=True
    
    return
        

# Update condor config with
# collector and negotiator settings
######################################
def setup_collector(default_poolname,nr_secondary_collectors,secondary_collector_port_diff=2):
    global CONDOR_BASE_PATH
    global COLLECTOR_INSTALLED
    global CONDOR_UPD_CONFIG_FILE
    
    a_poolname=raw_input("What name would you like to use for this pool?: [%s] "%default_poolname)
    if a_poolname=="":
        a_poolname=default_poolname

    default_collector_port=9618
    while 1:
        collector_port_str=raw_input("What port should the collector be running?: [%i] "%default_collector_port)
        if collector_port_str.strip() == "":
            collector_port_str = "9618"
        try:
            collector_port=int(collector_port_str)
        except:
            print "%s not a number"%collector_port_str
            continue
        if collector_port>65535:
            print "Cannot use port number that high: %i"%collector_port
            continue
        if collector_port<1:
            print "Cannot use port number that low: %i"%collector_port
            continue
        if collector_port<1024:
            if os.getuid()!=0:
                print "Only root can use ports below 1024: %i"%collector_port
                continue
            yn=raw_input("Do you really want to use the privileged port %i? (y/n)"%collector_port)
            if yn!='y':
                continue
        # we have a valid port
        break
        

    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## This is a Collector machine, limit deamons\n")
        config_fd.write("######################################################\n")
        config_fd.write("DAEMON_LIST   = MASTER, COLLECTOR, NEGOTIATOR\n")
        config_fd.write("COLLECTOR_NAME = %s\n"%a_poolname)
        config_fd.write("COLLECTOR_HOST  = $(CONDOR_HOST):%i\n\n"%collector_port)
        config_fd.write("############################################################\n")
        config_fd.write("## Negotiator tuning\n")
        config_fd.write("############################################################\n")
        config_fd.write("# Prefer newer claims as they are more likely to be alive\n")
        config_fd.write("NEGOTIATOR_POST_JOB_RANK = MY.LastHeardFrom\n")
        config_fd.write("# Increase negotiation frequency, as new glideins do not trigger a reschedule \n")
        config_fd.write("NEGOTIATOR_INTERVAL = 60\n")
        config_fd.write("NEGOTIATOR_MAX_TIME_PER_SUBMITTER=40\n")
        config_fd.write("NEGOTIATOR_MAX_TIME_PER_PIESPIN=20\n")
        config_fd.write("# Prevent preemption\n")
        config_fd.write("PREEMPTION_REQUIREMENTS = False\n")
        config_fd.write("# negotiator/GCB optimization\n")
        config_fd.write("NEGOTIATOR_INFORM_STARTD = False\n")

        if (default_poolname == "My pool"):
            config_fd.write("# Causes Negotiator to run faster. PREEMPTION_REQUIREMENTS and all condor_startd rank expressions must be False for NEGOTIATOR_CONSIDER_PREEMPTION to be False\n")
            config_fd.write("NEGOTIATOR_CONSIDER_PREEMPTION = False\n")


        if nr_secondary_collectors>0:
            config_fd.write("\n################################################\n")
            config_fd.write("## Secondary collectors\n")
            config_fd.write("################################################\n")

            config_fd.write("\n# Define sub-collectors, their ports and their log files\n")
            for collector_nr in range(nr_secondary_collectors):
                config_fd.write("COLLECTOR%i = $(COLLECTOR)\n"%collector_nr)
                config_fd.write('COLLECTOR%i_ENVIRONMENT = "_CONDOR_COLLECTOR_LOG=$(LOG)/Collector%iLog"\n'%(collector_nr,collector_nr))
                config_fd.write("COLLECTOR%i_ARGS = -f -p %i\n\n"%(collector_nr,collector_port+secondary_collector_port_diff+collector_nr))

            config_fd.write("# Add subcollectors to the list of things to start\n")
            config_fd.write("DAEMON_LIST = $(DAEMON_LIST) \\\n")
            for collector_nr in range(nr_secondary_collectors):
                config_fd.write("COLLECTOR%i \\\n"%collector_nr)

            config_fd.write("\n# forward ads to the main collector\n# (this is ignored by the main collector, since the address matches itself)\n")
            config_fd.write("CONDOR_VIEW_HOST = $(COLLECTOR_HOST)\n")

        config_fd.write("\n######################################################\n")
        config_fd.write("## DISABLE VOMS CHECKING\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("COLLECTOR.USE_VOMS_ATTRIBUTES = False\n")
        config_fd.write("NEGOTIATOR.USE_VOMS_ATTRIBUTES = False\n")
    finally:
        config_fd.close()

    COLLECTOR_INSTALLED=1
    return


# Update condor config with
# schedd settings
################################
def setup_main_schedd():
    global CONDOR_BASE_PATH
    global COLLECTOR_INSTALLED
    global MAIN_SCHEDD_INSTALLED
    global QUILL_CONFIG_DONE
    global CONDOR_UPD_CONFIG_FILE

    # not all the use cases need Quill
    if QUILL_CONFIG_DONE:
        schedd_daemons="SCHEDD, QUILL"
    else:
        schedd_daemons="SCHEDD"

    if not COLLECTOR_INSTALLED:
        # the collector is running on another node, ask which one
        while 1:
            pool_node=raw_input("What node is the collector running (i.e. CONDOR_HOST)?: ")
            try:
                socket.gethostbyname(pool_node.split(':')[0])
            except:
                print "'%s' not a valid host name!"%pool_node
                continue
            #have a valid pool_node
            break
        
        config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
        try:
            config_fd.write("\n######################################################\n")
            config_fd.write("## Point to the collector node\n")
            config_fd.write("######################################################\n")
            config_fd.write("CONDOR_HOST = %s\n\n"%pool_node)
            config_fd.write("######################################################\n")
            config_fd.write("## This is a Schedd machine\n")
            config_fd.write("######################################################\n")
            config_fd.write("DAEMON_LIST   = MASTER, %s\n\n"%schedd_daemons)
        finally:
            config_fd.close()
    else:
        config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
        try:
            config_fd.write("######################################################\n")
            config_fd.write("## This is both a Collector and a Schedd machine\n")
            config_fd.write("######################################################\n")
            config_fd.write("DAEMON_LIST   = $(DAEMON_LIST) %s\n\n"%schedd_daemons)
        finally:
            config_fd.close()

    ################################
    # Set optimized schedd values
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## Schedd tuning\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("# Allow up to 6k concurrent running jobs\n")
        config_fd.write("MAX_JOBS_RUNNING        = 6000\n")
        config_fd.write("# Start max of 50 jobs every 2 seconds\n")
        config_fd.write("JOB_START_DELAY = 2\n")
        config_fd.write("JOB_START_COUNT = 50\n")
        config_fd.write("# Stop 30 jobs every seconds\n")
        config_fd.write("# This is needed to prevent glexec overload, when used\n")
        config_fd.write("# Works for Condor v7.3.1 and up only, but harmless for older versions\n")
        config_fd.write("JOB_STOP_DELAY = 1\n")
        config_fd.write("JOB_STOP_COUNT = 30\n\n")
        config_fd.write("# Raise file transfer limits\n")
        config_fd.write("# no upload limits, since JOB_START_DELAY limits that\n")
        config_fd.write("MAX_CONCURRENT_UPLOADS = 0\n")
        config_fd.write("# but do limit downloads, as they are asyncronous\n")
        config_fd.write("MAX_CONCURRENT_DOWNLOADS = 100\n\n")
        config_fd.write("# Prevent checking on ImageSize\n")
        config_fd.write("APPEND_REQ_VANILLA = (Memory>=1)\n\n")
        config_fd.write("# Prevent preemption\n")
        config_fd.write("MAXJOBRETIREMENTTIME = $(HOUR) * 24 * 7\n\n")
        config_fd.write("#GCB optimization\n")
        config_fd.write("SCHEDD_SEND_VACATE_VIA_TCP = True\n")
        config_fd.write("STARTD_SENDS_ALIVES = True\n")
        config_fd.write("#Reduce disk IO - paranoid fsyncs are usully not needed\n")
        config_fd.write("ENABLE_USERLOG_FSYNC = False\n")
    finally:
        config_fd.close()

    MAIN_SCHEDD_INSTALLED=1
    return


# Ask the user if it has PostgreSQL installed
# Install one else
########################################
def query_postgresql():
    global POSTGRESQL_PORT

    while 1:
        yn=raw_input("Do you have already a PostgreSQL installation?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 

        if yn=="y":
            default_port="5432"
            user_port=raw_input("What port is it running on?: [%s] "%default_port)
            if user_port=="":
                user_port=default_port

            # verify the port is registered to postgres
            fd=open("/etc/services","r")
            try:
                lines=fd.readlines()
            finally:
                fd.close()
            found_port=0
            for line in lines:
                if line[:8]=="postgres":
                    if line[8:].find("%s/"%user_port)>=0:
                        found_port=1
                        break
            if not found_port:
                print "Postgres port %s not registered in /etc/services"%user_port
                continue
            
            # found and verified the installation
            POSTGRESQL_PORT=user_port
            return
        else:
            yn=raw_input("Do you want to install the PostgreSQL server?: (y/n) ")
            if (yn!="y"):
                continue # do not install, ask again
            if os.getuid()!=0:
                print "I can only install postgresql as root!"
                continue
            try:
                # install postgreSQL server
                install_postgresql()
            except RuntimeError,e:
                print e
                continue
            return

# Install PostgreSQL server
################################
def install_postgresql():
    global POSTGRESQL_PORT

    if os.getuid()!=0:
        raise RuntimeError, "I can only install postgresql as root!"


    print "Installing PostgreSQL"
    print

    ############################
    # Ask where rpm is running

    print "You must manually download the proper PostgreSQL RPM from the"
    print "official site (http://www.postgresql.org/ftp/binary/)"
    print "You will need the following files:"
    print "  postgresql-*.rpm"
    print "  postgresql-libs-*.rpm"
    print "  postgresql-server-*.rpm"
    print "Version v8.2.4 has been tested, but you should always use the"
    print "latest stable version"
    while 1:
        rpm_fname=raw_input("What is the name of the base PostgreSQL RPM?: ")
        rpm_fname=os.path.abspath(rpm_fname)
        rpm_dir=os.path.dirname(rpm_fname)
        rpm_short_name=os.path.basename(rpm_fname)

        if rpm_short_name[:11]!='postgresql-':
            print "File '%s' not a postgres rpm! (should be something like 'postgresql-8.2.3-1PGDG.i686.rpm'"%rpm_fname
            continue

        # needs 2 more rpms
        rpm2_short_name=rpm_short_name[:11]+'libs-'+rpm_short_name[11:]
        rpm2_fname=os.path.join(rpm_dir,rpm2_short_name)
        rpm3_short_name=rpm_short_name[:11]+'server-'+rpm_short_name[11:]
        rpm3_fname=os.path.join(rpm_dir,rpm3_short_name)


        problems=0
        for f in (rpm_fname,rpm2_fname,rpm3_fname):
            if not os.path.isfile(f):
                print "File '%s' not found!"%f
                problems=1
                break
            err=os.system("rpm -qv -p %s"%f)
            if err!=0:
                print "'%s' is not a valid RPM!"%f
                problems=1
                break
        if problems:
            continue # ask again

        # files found and verified
        break

    ##########################
    # Install the RPM
    print "Installing the PostgreSQL RPM"
    err=os.system("rpm -i %s %s %s"%(rpm_fname,rpm2_fname,rpm3_fname))
    if err!=0:
        raise RuntimeError, "Installation of the RPMs failed!"
    print


    ##########################
    # create the database dir
    def_dir="/var/lib/pgsql/data"
    db_dir=def_dir
    db_dir=create_empty_dir("Where do you want to host the DB data?: ",def_dir)
    os.chmod(db_dir,stat.S_IRWXU)
    os.chown(db_dir,pwd.getpwnam("postgres")[2],pwd.getpwnam("postgres")[3])

    ####################################################
    # The RPM expects it in a standard location
    # Create a symlink is user asked for a different one
    if db_dir!=def_dir:
        if os.path.islink(def_dir):
            os.unlink(def_dir) # remove the old symlink
        elif os.path.exists(def_dir):
            # an old dir exists, rename
            os.rename(def_dir,def_dir+".old_"+time.strftime("%Y%m%d.%H%M"))

        os.symlink(db_dir,def_dir)

    ##########################
    # Initialize it
    print "Initializing PostgreSQL"
    print 'su - postgres -c "initdb -A \'ident sameuser\' -D %s"'%def_dir
    err=os.system('su - postgres -c "initdb -A \'ident sameuser\' -D %s"'%def_dir)
    if err!=0:
        raise RuntimeError, "Initialization of postgresql DB failed!"


    ##########################
    # Select the port
    default_port="5432"
    while 1:
        db_port=raw_input("What port shoud it run on?: [%s] "%default_port)
        if db_port=="":
            db_port=default_port

        # verify the port is registered to postgres
        try:
            db_port_nr=int(db_port)
        except ValueError:
            print "'%s' not a number!"%db_port
            continue
        if (db_port_nr<1) or (db_port_nr>65500):
            print "'%s' out of range!"%db_port
            continue
        #verified
        break

    ##########################
    # Configure network access
    fd=open("/var/lib/pgsql/data/postgresql.conf","a")
    try:
        fd.write("\n###############################################\n")
        fd.write("# Enable connections on all network interfaces \n")
        fd.write("###############################################\n")
        fd.write("listen_addresses = '*'\n\n")
        fd.write("###############################################\n")
        fd.write("# Configure the IP port \n")
        fd.write("###############################################\n")
        fd.write("port = %s\n\n"%db_port)
    finally:
        fd.close()
    
    ##########################
    # Start PostgreSQL
    err=os.system('/etc/init.d/postgresql start')
    if err!=0:
        raise RuntimeError, "Starting of postgresql DB failed!\nSee /var/lib/pgsql/pgstartup.log."


    ######################################
    # Implement a more restrictive policy
    err=os.system('su - postgres -c \'psql -c "REVOKE CREATE ON SCHEMA public FROM PUBLIC;"\'')
    if err!=0:
        raise RuntimeError, "Error restricting postgres DB!"

    err=os.system('su - postgres -c \'psql -d template1 -c "REVOKE CREATE ON SCHEMA public FROM PUBLIC;"\'')
    if err!=0:
        raise RuntimeError, "Error restricting template1 DB!"


    #################################
    # PostgreSQL installed
    print
    print "PostgreSQL installed"
    print
    POSTGRESQL_PORT=db_port
    return

#  
########################################
def get_postgresql_passwd(question,user):
    global POSTGRESQL_PORT
    while 1:
        user_passwd=getpass.getpass(question)

        # this env variable is used instead of stdin
        os.environ['PGPASSWORD']=user_passwd

        # try to connect to postgres and look for passwd auth error
        # (anything else means user does not exist)
        err=os.system('psql -h %s -p %s -U "%s" -d postgres -c "\qecho OK"'%(socket.getfqdn(),POSTGRESQL_PORT,user))
        
        del os.environ['PGPASSWORD']

        if err==0:
            return user_passwd

        print "Wrong password!"


# Verify if quill settings were set 
# Install one else
########################################
def query_quill_db():
    global POSTGRESQL_PORT
    global QUILL_DB_SETUP
    global QUILL_DB_PASSWDS

    ########################################
    # first make sure postgress is installed
    if POSTGRESQL_PORT==None:
        query_postgresql()

    ########################################
    # Check if quill already accounts setup
    ask_confirm=0
    while 1:
        if ask_confirm:
            while raw_input("Have you configured quill accounts?: (y/n) ")!='y':
                pass
        ask_confirm=1 # if I need to try more than one, I should wait for user input

        #set a fake passwd nobody should ever use
        os.environ['PGPASSWORD']='dontuse'

        # try to connect to postgres and look for passwd auth error
        # (anything else means user does not exist)
        quill_users_err={}
        for user in ['quillreader','quillwriter']:
            quill_users_err[user]=os.system('psql -h %s -p %s -U "%s" -d postgres -c "\qecho Enabled" 2>&1 |grep -q "password authentication failed"'%(socket.getfqdn(),POSTGRESQL_PORT,user))
        
        del os.environ['PGPASSWORD']
        
        if (quill_users_err['quillreader']==0) and (quill_users_err['quillreader']==0):
            # already configured, ask for passwd
            reader_passwd=get_postgresql_passwd("Please enter the password used by quill to read from the DB: ",
                                                "quillreader")
            writer_passwd=get_postgresql_passwd("Please enter the password used by quill to update the DB: ",
                                                "quillwriter")
            QUILL_DB_PASSWDS={'reader':reader_passwd,'writer':writer_passwd}
            return
        elif (quill_users_err['quillreader']!=0) and (quill_users_err['quillreader']!=0):
            # not yet configured, do it
            print "Quill accounts not found"
            print
            if os.getuid()==0:
                setup_quill_db()
                return
            else:
                print "I can only configure quill accounts as root!"
        else:
            print "Quill only partially setup! Please fix it before continuing."
            

# Configure the quill settings in DB
####################################
def setup_quill_db():
    global QUILL_DB_PASSWDS
    
    if os.getuid()!=0:
        raise RuntimeError, "I can only setup postgresql quill settings as root!"

    print
    print "Creating Quill accounts in PostgreSQL"
    print

    ##################################
    # get passwords
    reader_passwd=getpass.getpass("Please enter the password used by quill to read from the DB: ")
    writer_passwd=getpass.getpass("Please enter the password used by quill to update the DB: ")

    #########################################
    # Ask how open the read access should be
    deny_ro=raw_input("Deny remote RO access?: (y/n) ")

    ##################################
    # Add quill users in pg_hba.conf
    fd=open("/var/lib/pgsql/data/pg_hba.conf","r+")
    try:
        # read all lines in memory
        lines=fd.readlines()

        # insert the quill accounts

        # find the line to insert it
        # must be before any other config
        # but possibly after the comments
        for i in range(len(lines)):
            line=lines[i]
            if line.find('TYPE'):
                # found the comment line I want to insert after
                i=i+1
                break
            if not line[0] in ('#',' ','\t','\n'):
                # found a config line, insert here (even if not after comments)
                break

        
        lines.insert(i,"\n")
        lines.insert(i+1,"# Condor quill entries\n")
        if deny_ro!="y":
            lines.insert(i+2,"# Allow read from everywhere\n")
            lines.insert(i+3,"host \tall \tquillreader \t0.0.0.0/0 \tmd5\n")
        else:
            lines.insert(i+2,"# Limit read to the local machine\n")
            lines.insert(i+3,"host \tall \tquillreader \t%s/32 \tmd5\n"%socket.gethostbyname(socket.getfqdn()))
            
        lines.insert(i+4,"local \tall \tquillreader \t \tmd5\n")
        lines.insert(i+5,"# Limit writes to the local machine\n")
        lines.insert(i+6,"host \tall \tquillwriter \t%s/32 \tmd5\n"%socket.gethostbyname(socket.getfqdn()))
        lines.insert(i+7,"\n")

        # replace the contents with the new data
        fd.seek(0)
        fd.writelines(lines)
    finally:
        fd.close()
        
    #####################################
    # Tell postgres to reload the config
    err=os.system('/etc/init.d/postgresql reload')
    if err!=0:
        raise RuntimeError, "Error updating PostgreSQL!"

    ##########################################
    # Create and configure the quill accounts
    tmp_fname="/var/lib/pgsql/data/tmp_%s_%s.tmp"%(os.getpid(),time.time())
    fd=open(tmp_fname,"w")
    try:
        fd.write("CREATE USER quillreader NOCREATEDB PASSWORD '%s';\n"%reader_passwd)
        fd.write("CREATE USER quillwriter CREATEDB PASSWORD '%s';\n"%writer_passwd)
        fd.write("REVOKE CREATE ON SCHEMA public FROM PUBLIC;\n")
        fd.write("GRANT CREATE ON SCHEMA public TO quillwriter;\n")
        fd.write("GRANT USAGE ON SCHEMA public TO quillwriter;\n")
    finally:
        fd.close()

    try:
        os.chown(tmp_fname,pwd.getpwnam('postgres')[2],pwd.getpwnam('postgres')[3])

        err=os.system('su - postgres -c "psql -d template1 -f %s"'%tmp_fname)
        if err!=0:
            raise RuntimeError, "Error creating quill accounts!"
    finally:
        os.unlink(tmp_fname)

    err=os.system('su - postgres -c \'psql -c "REVOKE CREATE ON SCHEMA public FROM PUBLIC;"\'')
    if err!=0:
        raise RuntimeError, "Error restricting postgres DB!"


    ################################
    # Configured
    print
    print "Quill accounts setup done"
    print

    QUILL_DB_PASSWDS={'reader':reader_passwd,'writer':writer_passwd}
    return

# Configure Condor quill parameters
####################################
def setup_quill():
    global CONDOR_BASE_PATH
    global QUILL_DB_PASSWDS
    global POSTGRESQL_PORT
    global QUILL_CONFIG_DONE
    global CONDOR_USER
    global CONDOR_UPD_CONFIG_FILE

    if QUILL_DB_PASSWDS==None:
        query_quill_db()

    ################################
    # configure condor parameters
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n#############################\n")
        config_fd.write("# Quill settings\n")
        config_fd.write("#############################\n")
        config_fd.write("QUILL_ENABLED = TRUE\n")
        config_fd.write("QUILL_NAME = quill@$(FULL_HOSTNAME)\n")
        config_fd.write("QUILL_DB_NAME = quill\n")
        config_fd.write("QUILL_DB_QUERY_PASSWORD = %s\n"%QUILL_DB_PASSWDS['reader'])
        config_fd.write("QUILL_DB_IP_ADDR = $(HOSTNAME):%s\n"%POSTGRESQL_PORT)
        config_fd.write("QUILL_MANAGE_VACUUM = TRUE\n")
        config_fd.write("# defaults are way to high\n")
        config_fd.write("#in days\nQUILL_HISTORY_DURATION  = 7\n")
        config_fd.write("#in hours\nQUILL_HISTORY_CLEANING_INTERVAL = 6\n")
    finally:
        config_fd.close()

    ######################################
    # create the protected password file
    fd=open("%s/condor_local/spool/.quillwritepassword"%CONDOR_BASE_PATH,"w")
    try:
        fd.write("%s\n"%QUILL_DB_PASSWDS['writer'])
    finally:
        fd.close()
    os.chmod("%s/condor_local/spool/.quillwritepassword"%CONDOR_BASE_PATH,stat.S_IRUSR)
    os.chown("%s/condor_local/spool/.quillwritepassword"%CONDOR_BASE_PATH,
             pwd.getpwnam(CONDOR_USER)[2],pwd.getpwnam(CONDOR_USER)[3])

    QUILL_CONFIG_DONE=1
    return


# Create secondary_schedd_support_files
###############################################
def create_secondary_schedd_support_files():
    global CONDOR_BASE_PATH
    global CONDOR_LOCAL_DIR
    global QUILL_CONFIG_DONE
    global SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED

    ##############################
    # Secondary schedd setup file
    fd=open("%s/new_schedd_setup.sh"%CONDOR_BASE_PATH,"w")
    try:
        fd.write("if [ $# -ne 1 ]\n")
        fd.write("then\n")
        fd.write(' echo "Schedd name expected!"\n')
        fd.write(" return 1\n")
        fd.write("fi\n\n")
        
        fd.write("LD=%s\n"%CONDOR_LOCAL_DIR)
        if QUILL_CONFIG_DONE:
            fd.write("QDB=quill\n\n")

        fd.write("export _CONDOR_SCHEDD_NAME=schedd_$1\n")
        fd.write("export _CONDOR_MASTER_NAME=${_CONDOR_SCHEDD_NAME}\n")
        fd.write("# SCHEDD and MASTER names MUST be the same (Condor requirement)\n")
        if QUILL_CONFIG_DONE:
            fd.write("export _CONDOR_QUILL_NAME=quill_$1@`uname -n`\n")
            fd.write("export _CONDOR_QUILL_DB_NAME=${QDB}_$1\n")
            fd.write('export _CONDOR_DAEMON_LIST="MASTER,SCHEDD,QUILL"\n')
        else:
            fd.write('export _CONDOR_DAEMON_LIST="MASTER,SCHEDD"\n')
        fd.write("export _CONDOR_LOCAL_DIR=$LD/$_CONDOR_SCHEDD_NAME\n")
        fd.write("export _CONDOR_LOCK=$_CONDOR_LOCAL_DIR/lock\n\n")

        fd.write("unset LD\n")
        if QUILL_CONFIG_DONE:
            fd.write("unset QDB\n")
    finally:
        fd.close()
    os.chmod("%s/new_schedd_setup.sh"%CONDOR_BASE_PATH,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP)

    #######################################
    # Secondary schedd initialization file
    fd=open("%s/init_schedd.sh"%CONDOR_BASE_PATH,"w")
    try:
        fd.write("#!/bin/sh\n")
        fd.write("source %s/new_schedd_setup.sh $1\n"%CONDOR_BASE_PATH)
        fd.write("# add whatever other config you need\n")
        fd.write("# create needed directories\n")
        fd.write("%s/sbin/condor_init\n"%CONDOR_BASE_PATH)
        if QUILL_CONFIG_DONE:
            fd.write("# copy Quill writer passwd\n")
            fd.write("cp -p %s/spool/.quillwritepassword $_CONDOR_LOCAL_DIR/spool/\n"%CONDOR_LOCAL_DIR)
    finally:
        fd.close()
    os.chmod("%s/init_schedd.sh"%CONDOR_BASE_PATH,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    #######################################
    # Secondary schedd startup file
    fd=open("%s/start_master_schedd.sh"%CONDOR_BASE_PATH,"w")
    try:
        fd.write("#!/bin/sh\n")
        fd.write("source %s/new_schedd_setup.sh $1\n"%CONDOR_BASE_PATH)
        fd.write("# add whatever other config you need\n")
        fd.write("%s/sbin/condor_master\n"%CONDOR_BASE_PATH)
    finally:
        fd.close()
    os.chmod("%s/start_master_schedd.sh"%CONDOR_BASE_PATH,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED=1
    return

# Configure the secondary schedds
####################################
def configure_secondary_schedd(schedd_name):
    global CONDOR_BASE_PATH
    global CONDOR_IDS

    err=os.system('export CONDOR_IDS=%s; %s/init_schedd.sh %s'%(CONDOR_IDS,CONDOR_BASE_PATH,schedd_name))
    if err!=0:
        raise RuntimeError, "Failed to initialize schedd '%s'!"%schedd_name

    fd=open("%s/start_condor.sh"%CONDOR_BASE_PATH,"a")
    try:
        fd.write("%s/start_master_schedd.sh %s\n"%(CONDOR_BASE_PATH,schedd_name))
    finally:
        fd.close()

# Ask the user if it has HTTPd installed
# Install one else
########################################
def query_httpd():
    global HTTPD_PORT

    # TO DO
    # Create glideinWMS directory

    while 1:
        yn=raw_input("Do you have already an HTTPd installed?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 

        if yn=="y":
            default_port="80"
            httpd_port=raw_input("What port do you want to use?: [%s] "%default_port)
            if httpd_port=="":
                httpd_port=default_port

            try:
                hc=httplib.HTTPConnection(socket.getfqdn(),httpd_port)
                hc.connect()
                hc.close()
            except:
                print "No httpd found on %s:%s!"%(socket.getfqdn(),httpd_port)
                continue

            # found and verified the installation
            HTTPD_PORT=httpd_port
            return
        else:
            yn=raw_input("Do you want to install a HTTPd?: (y/n) ")
            if (yn!="y"):
                continue # do not install, ask again 
            try:
                install_httpd()
            except RuntimeError, e:
                print e
                continue
            return

# Install a HTTPd
####################################
def install_httpd():
    global HTTPD_PORT

    print
    print "Installing a httpd"
    print

    default_port="80"
    httpd_port=raw_input("What port do you want to use?: [%s] "%default_port)
    if httpd_port=="":
        httpd_port=default_port

    print "Select install method:"
    print " [1] using yum"
    print " [2] using RPMs"
    print " [3] changed my mind, do not install"

    while 1:
        option=raw_input("select: ")
        if option=='1':
            install_yum_httpd()
            break
        elif option=='2':
            install_rpm_httpd()
            break
        elif option=='3':
            raise RuntimeError,"User cancelled the httpd installation"
        else:
            print "Invalid choice '%s'!"%option

    #################################
    # configure port
    fd=open("/etc/httpd/conf/httpd.conf","r")
    try:
        lines=fd.readlines()
    finally:
        fd.close()

    # comment old port and put the correct one
    # also limit modules to the trusted ones
    needed_modules=('access_module','include_module','log_config_module',
                    'mime_magic_module','expires_module','deflate_module',
                    'headers_module','setenvif_module','mime_module',
                    'status_module','autoindex_module','negotiation_module',
                    'dir_module','imap_module','alias_module','rewrite_module',
                    'cache_module','file_cache_module','mem_cache_module',
                    'authz_host_module','authz_default_module')
    
    fd=open("/etc/httpd/conf/httpd.conf","w")
    try:
        for line in lines:
            linearr=line.split()
            if len(linearr)<1:
                fd.write(line) #empty line
            elif linearr[0].lower()=='listen':
                fd.write("#%s"%line)
                fd.write("Listen %s\n"%httpd_port)
            elif linearr[0].lower()=='loadmodule':
                if linearr[1] in needed_modules:
                    fd.write(line)
                else:
                    fd.write("#%s"%line) # disable
            else:
                fd.write(line)
    finally:
        fd.close()

    # disable also all the extensions in conf.d
    fnames=os.listdir('/etc/httpd/conf.d')
    for fname in fnames:
        if fname[-5:]=='.conf':
            os.rename("/etc/httpd/conf.d/%s"%fname,"/etc/httpd/conf.d/%s.org_%s"%(fname,time.strftime("%Y%m%d.%H%M")))

    
    ####################################
    # Create an empty top level page
    if not os.path.exists('/var/www/html/index.html'):
        try:
            fd=open('/var/www/html/index.html',"w")
            try:
                fd.write('<html>\n')
                fd.write('<body>\n')
                fd.write('</body>\n')
                fd.write('</html>\n')
            finally:
                fd.close()
        except:
            pass # the creation of this file is not strictly necessary, so ignore any errors

    ################################
    # start httpd
    err=os.system('/etc/init.d/httpd start')
    if err!=0:
        raise RuntimeError, "Failed to start httpd!"

    print
    print "HTTPd installed on port %s"%httpd_port
    print
    HTTPD_PORT=httpd_port
    return

def install_yum_httpd():
    err=os.system('yum -y install httpd')
    if err!=0:
        raise RuntimeError, "Failed to install httpd via yum!"

    # yum will not complain if it cannot find httpd
    # verify it is installed
    err=os.system('rpm -q --whatprovides httpd')
    if err!=0:
        raise RuntimeError, "HTTPd was not installed by yum!"

    return

def install_rpm_httpd():
    while 1:
        rpm_fname=raw_input("Where do you have the httpd RPM?: ")
        if not os.path.isfile(rpm_fname):
            print "File '%s' not found!"%rpm_fname
            continue
        err=os.system("rpm -qv -p %s"%rpm_fname)
        if err!=0:
            print "'%s' is not a valid RPM!"%rpm_fname
            continue

        # files found and verified
        break

    err=os.system('rpm -i %s'%rpm_fname)
    if err!=0:
        raise RuntimeError, "Failed to install httpd via rpm '%s'!"%rpm_fname

    return

#
# Check if a python module can be imported
###########################################
def check_import(module_name):
    while 1:
        err=os.system("python -c 'import %s'"%module_name)
        if err!=0:
            print "Python module %s not found!"%module_name
            yn=raw_input("Do you want to retry?: (y/n) ")
            if yn!='y':
                raise RuntimeError, "Failed to load %s"%module_name
            continue

        return

#
# Ask for the location of javascriptRRD
###########################################
def query_javascriptRRD():
    global JAVASCRIPTRRD_PATH,FLOT_PATH

    while 1:
        yn=raw_input("Do you have already a javascriptRRD installation?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 

        if yn=="y":
            user_dir=raw_input("Where is javascriptRRD installed?: ")
            user_dir=os.path.abspath(user_dir)
            if not os.path.exists(os.path.join(user_dir,"src/lib/rrdFile.js")):
                print "The provided directory is not hosting javascriptRRD"
                print "(%s not found)"%os.path.join(user_dir,"src/lib/rrdFile.js")
                continue
            JAVASCRIPTRRD_PATH=user_dir
            if FLOT_PATH==None:
                # JavascriptRRD often contains flot, check for it
                if os.path.exists(os.path.join(user_dir,"flot/jquery.flot.js")):
                    FLOT_PATH=os.path.join(user_dir,"flot")
            break
        else:
            print "Download a tarball (possibly with flot) from"
            print " http://sourceforge.net/projects/javascriptrrd/"
            print "untar it and let me know where it is."
            print
            continue

    return

#
# Ask for the location of Flot
###########################################
def query_flot():
    global FLOT_PATH

    while 1:
        yn=raw_input("Do you have already a Flot installation?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 

        if yn=="y":
            user_dir=raw_input("Where is Flot installed?: ")
            user_dir=os.path.abspath(user_dir)
            if not os.path.exists(os.path.join(user_dir,"jquery.flot.js")):
                print "The provided directory is not hosting Flot"
                print "(%s not found)"%os.path.join(user_dir,"jquery.flot.js")
                continue
            FLOT_PATH=user_dir
            break
        else:
            print "Download a tarball from"
            print " http://code.google.com/p/flot/"
            print "untar it and let me know where it is."
            print
            continue

    return

# Look for a rrdtool in the path
# Ask the user if there is none
# Install one else
########################################
def query_rrd():
    global RRD_BIN_PATH

    #############################
    # lokk if it is in the path
    fd=os.popen("which rrdtool")
    lines=fd.readlines()
    err=fd.close()
    if err==None: # found
        RRD_BIN_PATH=lines[0][:-1]
        return

    #################################
    # Ask user if it has it installed
    while 1:
        yn=raw_input("Do you have rrd installed?: (y/n) ")
        if yn!="y":
            yn=raw_input("Do you want to install it?: (y/n) ")
            if yn=="y":
                try:
                  return install_rrd()
                except RuntimeError, e:
                  print "%s"%e
            continue # get back to the first question
        #else
        rrd_path=raw_input("In what directory do you have the rrd binary?: ")
        rrd_path=os.path.abspath(rrd_path)

        # Use which to verify the new path
        fd=os.popen("export PATH=$PATH:%s;which rrdtool"%rrd_path)
        lines=fd.readlines()
        err=fd.close()
        if err!=None: # not found
            print "'%s' does not contain rrdtool!"%rrd_path
            continue

        print "rrdtool should be in the path for the glidein factory to properly work"
        yn=raw_input("Do you want to do it now?: (y/n) ")
        if yn=="y":
            ##################################################
            # Put rrd in path
            if os.getuid()==0: # different if root or not
                # as root

                # put rrd binaries in system wide path
                fd=open("/etc/profile.d/rrd.sh","w")
                try:
                    fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%rrd_path)
                    fd.write("  PATH=${PATH}:%s/bin\n"%rrd_path)
                    fd.write("fi\n")
                finally:
                    fd.close()
                os.chmod("/etc/profile.d/rrd.sh",
                         stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

                fd=open("/etc/profile.d/rrd.csh","w")
                try:
                    fd.write("set path = ( $path %s/bin )\n"%rrd_path)
                finally:
                    fd.close()
                os.chmod("/etc/profile.d/rrd.csh",
                         stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)
            else:
                # as regular user

                # put rrd path in .profile
                fd=open("%s/.profile"%os.environ['HOME'],"a")
                try:
                    fd.write("\n# rrd settings\n")
                    fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%rrd_path)
                    fd.write("  export PATH=${PATH}:%s/bin\n"%rrd_path)
                    fd.write("fi\n\n")
                finally:
                    fd.close()
        
                fd=open("%s/.bashrc"%os.environ['HOME'],"a")
                try:
                    fd.write("\n# rrd settings\n")
                    fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%rrd_path)
                    fd.write("  export PATH=${PATH}:%s/bin\n"%rrd_path)
                    fd.write("fi\n\n")
                finally:
                    fd.close()
        
                # and in .cshrc
                fd=open("%s/.cshrc"%os.environ['HOME'],"a")
                try:
                    fd.write("\n# rrd settings\n")
                    fd.write("set path = ( $path %s/bin )\n"%rrd_path)
                finally:
                    fd.close()

        else:
            print
            print "Remember to put '%s' in the path yourself!"%rrd_path
            print

        RRD_BIN_PATH=rrd_path
        return
    
# Install rrdtool
##########################################
def install_rrd():
    global RRD_BIN_PATH

    print
    print "You will now need the rrdtool RPMs"
    print "You can find them on http://dag.wieers.com/rpm/packages/rrdtool/"
    print "You will need the following RPMs:"
    print "  rrdtool-*.rpm"
    print "  perl-rrdtool-*.rpm"
    print "  python-rrdtool-*.rpm"
    print "Version 1.2.18 has been tested, but you should always use the"
    print "latest one"
    print
    while 1:
        rpm_fname=raw_input("What is the name of the base rrd RPM?: ")
        rpm_fname=os.path.abspath(rpm_fname)
        rpm_dir=os.path.dirname(rpm_fname)
        rpm_short_name=os.path.basename(rpm_fname)

        rpm2_short_name="perl-"+rpm_short_name
        rpm2_fname=os.path.join(rpm_dir,rpm2_short_name)

        rpm3_short_name="python-"+rpm_short_name
        rpm3_fname=os.path.join(rpm_dir,rpm3_short_name)


        problems=0
        for f in (rpm_fname,rpm2_fname,rpm3_fname):
            if not os.path.isfile(f):
                print "File '%s' not found!"%f
                problems=1
                break
            err=os.system("rpm -qv -p %s"%f)
            if err!=0:
                print "'%s' is not a valid RPM!"%f
                problems=1
                break
        if problems:
            continue # ask again

        # files found and verified
        break
        
    ##########################
    # Install the RPM
    print "Installing the rrd RPM"
    err=os.system("rpm -i %s %s %s"%(rpm_fname,rpm2_fname,rpm3_fname))
    if err!=0:
        raise RuntimeError, "Installation of the RPMs failed!"
    print

    return
   
# Get list of GCBs
##########################################
def get_gcb_list():
    print "Please list all the GCB servers you will be using"
    print "Leave an empty line when finished"
    gcb_list=[]
    while 1:
        gcb_entry=raw_input("GCB node: ")
        if gcb_entry=="":
            break # EOF

        try:
            gcb_ip=socket.gethostbyname(gcb_entry)
        except:
            print "'%s' not a valid host name!"%gcb_entry
            continue

        gcb_list.append(gcb_ip)

    return gcb_list


# Compare two entry elements
##########################################

def compare_entry_els(el1,el2):
    for attr in ('gatekeeper','rsl'):
        if el1[attr]!=el2[attr]:
            return False
    return True

# Get list of entry point from RESS
##########################################
def get_ress_glidein_entries(vo,             #vo can be None
                             entries_list,   # disctionary, will add to this
                             config_glexec): # bool, ask for glexec dir
    import condorMonitor

    if config_glexec:
        def_glexec_bin='OSG'
    else:
        def_glexec_bin='NONE'

    #
    # Note to self (Igor):
    # should ask if user wants to provide a VO, if not defined


    default_reqs=""
    if vo!=None:
        default_reqs='StringlistMember("VO:%s",GlueCEAccessControlBaseRule)'%vo

    default_python_filter="(int(GlueCEPolicyMaxCPUTime)==0) or (int(GlueCEPolicyMaxCPUTime)>(72*60))"

    while 1:
        while 1:
            default_ress_url='osg-ress-1.fnal.gov'
            ress_url=raw_input("Which RESS server should I use?: [%s] "%default_ress_url)
            if ress_url=="":
                ress_url=default_ress_url
            try:
                ress_ip=socket.gethostbyname(ress_url)
            except:
                print "'%s' is not a valid host name!"%ress_url
                continue
            #found and verified
            break

    
        select_reqs=raw_input("Select Condor RESS constraint: [%s] "%default_reqs)
        if select_reqs=="":
            select_reqs=default_reqs

        python_filter=raw_input("Define a python filter: [%s] "%default_python_filter)
        if python_filter=="":
            python_filter=default_python_filter
        python_filter_obj=compile(python_filter,"<string>","eval")

        # change defaults in case I need to do it again
        default_reqs=select_reqs
        default_python_filter=python_filter

        # Get gatekeepers from RESS
        ress_constraint='(GlueCEInfoContactString=!=UNDEFINED)&&(%s)'%select_reqs
        condor_obj=condorMonitor.CondorStatus(pool_name=ress_url)
        try:
            condor_obj.load(constraint=ress_constraint)
            condor_data=condor_obj.fetchStored()
        except:
            print "Failed to talk to '%s'"%ress_url
            continue # try again
        del condor_obj
        break # have the data, cont

    cluster_count={}
    ress_entries={}
    for condor_id in condor_data.keys():
        condor_el=condor_data[condor_id]

        if not eval(python_filter_obj,condor_el):
            continue # has not passed the filter

        cluster_name=condor_el['GlueClusterName']
        gatekeeper_name=condor_el['GlueCEInfoContactString']
        rsl='(queue=%s)(jobtype=single)'%condor_el['GlueCEName']
        site_name=condor_el['GlueSiteName']

        work_dir="OSG"
        ress_id={'type':'RESS','server':ress_url,'name':condor_id}
        entry_el={'gatekeeper':gatekeeper_name,'rsl':rsl,'gridtype':'gt2',
                  'work_dir':work_dir,'site_name':site_name,'glexec_path':def_glexec_bin,
                  'is_ids':[ress_id]}

        cluster_arr=cluster_name.split('.')
        if len(cluster_arr)<2:
            continue # something is wrong here, at least a.b expected

        t_found=False
        for t in ress_entries.keys():
            test_el=ress_entries[t]
            if compare_entry_els(test_el,entry_el):
                # found a duplicate entry, just add the additional ress entry to the list
                test_el['is_ids'].append(ress_id)
                t_found=True
                break
        if t_found:
            # found a duplicate entry, see next el
            continue
    
        cluster_id="ress_%s"%site_name

        count=1
        if cluster_count.has_key(cluster_id):
            count=cluster_count[cluster_id]+1
        cluster_count[cluster_id]=count

        if count==1:
            key_name=cluster_id
        else:
            key_name="%s_%i"%(cluster_id,count)

            if count==2: # rename id -> id_1
                key_name_tmp="%s_1"%cluster_id
                ress_entries[key_name_tmp]=ress_entries[cluster_id]
                del ress_entries[cluster_id]

        ress_entries[key_name]=entry_el


    for t in ress_entries.keys():
        test_el=ress_entries[t]
        t_found=False
        for l in entries_list.keys():
            l_el=entries_list[l]
            if compare_entry_els(test_el,l_el):
                # found a duplicate entry
                l_el['is_ids']+=test_el['is_ids']
                del ress_entries[t] # discard the ress_specific entry
                t_found=True
                break

    ress_keys=ress_entries.keys()
    ress_keys.sort()

    print "Found %i additional entries"%len(ress_keys)
    yn=raw_input("Do you want to use them all?: (y/n) ")
    if yn=="y":
        # simply copy all of them
        for key in ress_keys:
            entries_list[key]=ress_entries[key]
        return
    
    print "This is the list of entries found in RESS:"
    for key in ress_keys:
        print "[%s] %s(%s)"%(string.ljust(key,20),ress_entries[key]['gatekeeper'],ress_entries[key]['rsl'])

    print "Select the indexes you want to include"
    print "Use a , separated list to include more than one"
    while 1:
        idxes=raw_input("Please select: ")
        idx_arr=idxes.split(',')
        problems=0
        for idx in idx_arr:
            if not (idx in ress_keys):
                print "'%s' is not a valid index!"%idx
                problems=1
                break
        if problems:
            continue

        # got them
        break

    yn=raw_input("Do you want to customize them?: (y/n) ")
    if yn=="y":
        # customize them
        for idx in idx_arr:
            work_dir=raw_input("Work dir for '%s': [%s] "%(idx,ress_entries[idx]['work_dir']))
            if work_dir!="":
                ress_entries[idx]['work_dir']=work_dir
            site_name=raw_input("Site name for '%s': [%s] "%(idx,ress_entries[idx]['site_name']))
            if site_name!="":
                ress_entries[idx]['site_name']=site_name

        if config_glexec:
            glexec_path=raw_input("gLExec path for '%s': [%s] "%(idx,ress_entries[idx]['glexec_path']))
            if glexec_path!="":
                ress_entries[idx]['glexec_path']=glexec_path
            

    for idx in idx_arr:
        entries_list[idx]=ress_entries[idx]

    return


# Get list of entry point from BDII
##########################################
def get_bdii_glidein_entries(vo,             #vo can be None
                             entries_list,   # dictionary, will add to this
                             config_glexec): # bool, ask for glexec dir
    import ldapMonitor

    if config_glexec:
        def_glexec_bin='/opt/glite/sbin/glexec'
    else:
        def_glexec_bin='NONE'

    while 1:
        default_bdii_url='exp-bdii.cern.ch'
        bdii_url=raw_input("Which BDII server should I use?: [%s] "%default_bdii_url)
        if bdii_url=="":
            bdii_url=default_bdii_url
        try:
            bdii_ip=socket.gethostbyname(bdii_url)
        except:
            print "'%s' is not a valid host name!"%bdii_url
            continue
        #found and verified
        break

    #
    # Note to self (Igor):
    # should ask if user wants to provide a VO, if not defined

    default_reqs=""
    if vo!=None:
        default_reqs='%s(GlueCEAccessControlBaseRule=VO:%s)'%(default_reqs,vo)

    select_reqs=raw_input("Define a BDII LDAP filter: [%s] "%default_reqs)
    if select_reqs=="":
        select_reqs=default_reqs


    default_python_filter="(int(GlueCEPolicyMaxCPUTime)==0) or (int(GlueCEPolicyMaxCPUTime)>(72*60))"
    python_filter=raw_input("Define a python filter: [%s] "%default_python_filter)
    if python_filter=="":
        python_filter=default_python_filter
    python_filter_obj=compile(python_filter,"<string>","eval")

    bdii_obj=ldapMonitor.BDIICEQuery(bdii_url,additional_filter_str=select_reqs)
    bdii_obj.load()
    bdii_data=bdii_obj.fetchStored()
    del bdii_obj

    cluster_count={}
    bdii_entries={}
    for ldap_id in bdii_data.keys():
        el2=bdii_data[ldap_id]

        # LDAP returns everything in lists... convert to values (i.e. get first element from list)
        scalar_el={}
        for k in el2.keys():
            scalar_el[k]=el2[k][0]
        if not eval(python_filter_obj,scalar_el):
            continue # has not passed the filter
        
        work_dir="."
        gatekeeper="%s:%s/jobmanager-%s"%(el2['GlueCEHostingCluster'][0],el2['GlueCEInfoGatekeeperPort'][0],el2['GlueCEInfoJobManager'][0])
        rsl="(queue=%s)(jobtype=single)"%el2['GlueCEName'][0]

        site_name=el2['Mds-Vo-name'][0]
        cluster_id="bdii_%s"%site_name

        bdii_id={'type':'BDII','server':bdii_url,'name':ldap_id}

        count=1
        if cluster_count.has_key(cluster_id):
            count=cluster_count[cluster_id]+1
        cluster_count[cluster_id]=count

        if count==1:
            key_name=cluster_id
        else:
            key_name="%s_%i"%(cluster_id,count)

            if count==2: # rename id -> id_1
                key_name_tmp="%s_1"%cluster_id
                bdii_entries[key_name_tmp]=bdii_entries[cluster_id]
                del bdii_entries[cluster_id]

        guess_glexec_bin=def_glexec_bin
        if guess_glexec_bin!='NONE':
           if el2['GlueCEHostingCluster'][0][-3:] in ('gov','edu'):
             # these should be OSG
             guess_glexec_bin='OSG'
           else:
             # I assume everybody else uses glite software
             guess_glexec_bin='/opt/glite/sbin/glexec'

        bdii_entries[key_name]={'gatekeeper':gatekeeper,'rsl':rsl,'gridtype':'gt2',
                                'work_dir':work_dir,'site_name':site_name,'glexec_path':guess_glexec_bin,
                                'is_ids':[bdii_id]}
        
    for t in bdii_entries.keys():
        test_el=bdii_entries[t]
        t_found=False
        for l in entries_list.keys():
            l_el=entries_list[l]
            if compare_entry_els(test_el,l_el):
                # found a duplicate entry
                l_el['is_ids']+=test_el['is_ids']
                del bdii_entries[t] # discard the bdii_specific entry
                t_found=True
                break

    bdii_keys=bdii_entries.keys()
    bdii_keys.sort()

    print "Found %i additional entries"%len(bdii_keys)
    yn=raw_input("Do you want to use them all?: (y/n) ")
    if yn=="y":
        # simply copy all of them
        for key in bdii_keys:
            entries_list[key]=bdii_entries[key]
        return
    
    print "This is the list of entries found in BDII:"
    for key in bdii_keys:
        print "[%s] %s(%s)"%(string.ljust(key,20),bdii_entries[key]['gatekeeper'],bdii_entries[key]['rsl'])

    print "Select the indexes you want to include"
    print "Use a , separated list to include more than one"
    while 1:
        idxes=raw_input("Please select: ")
        idx_arr=idxes.split(',')
        problems=0
        for idx in idx_arr:
            if not (idx in bdii_keys):
                print "'%s' is not a valid index!"%idx
                problems=1
                break
        if problems:
            continue

        # got them
        break

    yn=raw_input("Do you want to customize them?: (y/n) ")
    if yn=="y":
        # customize them
        for idx in idx_arr:
            work_dir=raw_input("Work dir for '%s': [%s] "%(idx,bdii_entries[idx]['work_dir']))
            if work_dir!="":
                bdii_entries[idx]['work_dir']=work_dir
            site_name=raw_input("Site name for '%s': [%s] "%(idx,bdii_entries[idx]['site_name']))
            if site_name!="":
                bdii_entries[idx]['site_name']=site_name

        if config_glexec:
            glexec_path=raw_input("gLExec path for '%s': [%s] "%(idx,bdii_entries[idx]['glexec_path']))
            if glexec_path!="":
                bdii_entries[idx]['glexec_path']=glexec_path
            

    for idx in idx_arr:
        entries_list[idx]=bdii_entries[idx]

    return

##########################################
if __name__ == '__main__':
    main()

